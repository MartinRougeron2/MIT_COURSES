1
00:00:00,080 --> 00:00:02,430
The following content is
provided under a Creative

2
00:00:02,430 --> 00:00:03,810
Commons license.

3
00:00:03,810 --> 00:00:06,050
Your support will help
MIT OpenCourseWare

4
00:00:06,050 --> 00:00:10,150
continue to offer high quality
educational resources for free.

5
00:00:10,150 --> 00:00:12,690
To make a donation or to
view additional materials

6
00:00:12,690 --> 00:00:16,600
from hundreds of MIT courses,
visit MIT OpenCourseWare

7
00:00:16,600 --> 00:00:17,265
at ocw.mit.edu.

8
00:00:25,755 --> 00:00:26,630
PROFESSOR: All right.

9
00:00:26,630 --> 00:00:29,750
Welcome to 6890,
Algorithmic Lower Bounds,

10
00:00:29,750 --> 00:00:31,030
Fun with Hardness Proofs.

11
00:00:31,030 --> 00:00:33,210
I am your host, Erik Demaine.

12
00:00:33,210 --> 00:00:40,100
We have on my left Jayson Lynch
and Sarah Eisenstat, your TAs.

13
00:00:40,100 --> 00:00:43,650
First question is what
is this class about?

14
00:00:43,650 --> 00:00:46,160
The tag line is
hardness made easy.

15
00:00:46,160 --> 00:00:49,620
In general, we're interested
in proving problems hard.

16
00:00:49,620 --> 00:00:52,420
Proving that there's no fast
algorithms to solve problems

17
00:00:52,420 --> 00:00:54,970
under certain assumptions.

18
00:00:54,970 --> 00:00:59,520
And the goal is to give
you a practical guide

19
00:00:59,520 --> 00:01:02,310
and give you lots of experience
in how to prove problems hard,

20
00:01:02,310 --> 00:01:04,640
to make that an easy process.

21
00:01:04,640 --> 00:01:06,170
There's a lot of
technique involved,

22
00:01:06,170 --> 00:01:09,270
and the more experience
you get improving hardness,

23
00:01:09,270 --> 00:01:11,670
it becomes relatively
straightforward to take

24
00:01:11,670 --> 00:01:14,260
whatever problem you're
interested in and prove it hard

25
00:01:14,260 --> 00:01:17,080
So the three of us
are pretty good at it,

26
00:01:17,080 --> 00:01:20,620
and our goal is to share
with you that expertise so

27
00:01:20,620 --> 00:01:23,570
that everyone's good at it.

28
00:01:23,570 --> 00:01:25,797
This is not a complexity class.

29
00:01:25,797 --> 00:01:27,880
Because there are lots of
computational complexity

30
00:01:27,880 --> 00:01:29,780
classes at MIT.

31
00:01:29,780 --> 00:01:32,670
So we're not going
to talk about lots

32
00:01:32,670 --> 00:01:35,740
of beautiful deep
mathematics about relations

33
00:01:35,740 --> 00:01:37,330
between complexity classes.

34
00:01:37,330 --> 00:01:39,680
We're just going to use
a lot of those results

35
00:01:39,680 --> 00:01:41,815
wholesale without proving them.

36
00:01:41,815 --> 00:01:44,190
And you can take one of the
many computational complexity

37
00:01:44,190 --> 00:01:45,840
classes to get that background.

38
00:01:45,840 --> 00:01:49,140
I will tell you everything you
need to know about complexity.

39
00:01:49,140 --> 00:01:50,800
So if you've taken
a complexity class,

40
00:01:50,800 --> 00:01:52,591
there will be a small
amount of repetition.

41
00:01:52,591 --> 00:01:54,870
Most of it will be contained
in today's lecture.

42
00:01:54,870 --> 00:01:58,330
But very little repetition, but
also no background required.

43
00:01:58,330 --> 00:02:01,110
I do expect you to have a
background in algorithms,

44
00:02:01,110 --> 00:02:04,410
because we take a kind of
algorithmic perspective.

45
00:02:04,410 --> 00:02:09,870
I call it an anti-algorithmic
perspective, if you like.

46
00:02:09,870 --> 00:02:13,250
And so, yeah.

47
00:02:13,250 --> 00:02:15,320
So that's what this class is.

48
00:02:15,320 --> 00:02:17,150
Why would you want
to take this class?

49
00:02:17,150 --> 00:02:18,100
Why prove hardness?

50
00:02:18,100 --> 00:02:20,990
Well, the main reason
is to show that you

51
00:02:20,990 --> 00:02:23,345
can't design algorithms
in whatever model

52
00:02:23,345 --> 00:02:24,220
you're interested in.

53
00:02:24,220 --> 00:02:27,149
That encourages you either
to change the problem, like

54
00:02:27,149 --> 00:02:28,690
to look for
approximation algorithms,

55
00:02:28,690 --> 00:02:30,197
or fixed parameter algorithms.

56
00:02:30,197 --> 00:02:32,280
That's, of course, the
topics of algorithms class.

57
00:02:32,280 --> 00:02:34,196
Our goal is to prove
when these things are not

58
00:02:34,196 --> 00:02:35,881
possible in this class.

59
00:02:35,881 --> 00:02:37,630
We're going to master
a lot of techniques.

60
00:02:37,630 --> 00:02:42,800
You'll see a lot of key problems
to reduce from to your problem.

61
00:02:42,800 --> 00:02:45,290
Get a lot of proof
styles that are

62
00:02:45,290 --> 00:02:47,380
quite common in the
literature, but unless you've

63
00:02:47,380 --> 00:02:48,910
done them and
experienced them, it's

64
00:02:48,910 --> 00:02:50,630
hard to know what to look for.

65
00:02:50,630 --> 00:02:53,729
And one of the big ideas
in this class is gadgets.

66
00:02:53,729 --> 00:02:55,270
And you may have
seen gadgets before,

67
00:02:55,270 --> 00:02:58,159
but we're going to explore
gadgets to their fullest.

68
00:02:58,159 --> 00:02:59,950
The idea of taking lots
of small components

69
00:02:59,950 --> 00:03:02,857
and combining them together.

70
00:03:02,857 --> 00:03:04,440
Even if you don't
care about hardness,

71
00:03:04,440 --> 00:03:06,920
I think this class is a
lot of fun for two reasons.

72
00:03:06,920 --> 00:03:08,790
Maybe three.

73
00:03:08,790 --> 00:03:10,705
One is that you see
lots of cool connections

74
00:03:10,705 --> 00:03:12,830
between different problems
that you might not think

75
00:03:12,830 --> 00:03:14,380
are related at first glance.

76
00:03:14,380 --> 00:03:15,870
Most of the problems
in this class

77
00:03:15,870 --> 00:03:17,450
are equivalent to each other.

78
00:03:17,450 --> 00:03:18,820
And it's all about proving that.

79
00:03:18,820 --> 00:03:21,380
That's the goal.

80
00:03:21,380 --> 00:03:23,850
We'll also study
lots of fun problems,

81
00:03:23,850 --> 00:03:25,050
like Super Mario Brothers.

82
00:03:25,050 --> 00:03:27,380
We'll NP-complete today.

83
00:03:27,380 --> 00:03:29,704
Tetris, we'll do in
a lecture or two.

84
00:03:29,704 --> 00:03:32,120
There are also serious problems,
so if you don't like fun,

85
00:03:32,120 --> 00:03:34,020
don't worry.

86
00:03:34,020 --> 00:03:36,800
And in general,
proving problems hard

87
00:03:36,800 --> 00:03:38,660
is really like solving a puzzle.

88
00:03:38,660 --> 00:03:39,920
And it's a lot of fun.

89
00:03:39,920 --> 00:03:42,030
And this is one
of the rare areas

90
00:03:42,030 --> 00:03:44,330
where you can basically
play with puzzles all day,

91
00:03:44,330 --> 00:03:46,650
and in the end have
publishable papers.

92
00:03:46,650 --> 00:03:48,750
So we're going to do
that in particular

93
00:03:48,750 --> 00:03:51,040
through an open problem
session, which is optional.

94
00:03:51,040 --> 00:03:53,200
If you want to
solve open problems

95
00:03:53,200 --> 00:03:54,970
that no one knows
the answer to, we

96
00:03:54,970 --> 00:03:56,880
will try to do it once a week.

97
00:03:56,880 --> 00:04:00,070
We'll be sending email
with a call for times when

98
00:04:00,070 --> 00:04:02,670
that's ideal for everybody.

99
00:04:02,670 --> 00:04:07,750
We talked about background
and requirements.

100
00:04:07,750 --> 00:04:09,160
So first requirement
of the class

101
00:04:09,160 --> 00:04:11,930
is to fill out the survey, which
is circulating Does anyone not

102
00:04:11,930 --> 00:04:13,060
have a survey?

103
00:04:13,060 --> 00:04:13,560
Good.

104
00:04:13,560 --> 00:04:14,490
Everyone has one.

105
00:04:14,490 --> 00:04:19,230
So fill that out, so
we know who you are.

106
00:04:19,230 --> 00:04:20,969
You should also join
the mailing list.

107
00:04:20,969 --> 00:04:22,760
By filling out that
survey, you should auto

108
00:04:22,760 --> 00:04:23,676
join the mailing list.

109
00:04:23,676 --> 00:04:25,780
But just in case, if you
haven't, the mailing list

110
00:04:25,780 --> 00:04:26,821
is on the course website.

111
00:04:29,300 --> 00:04:30,811
Yeah.

112
00:04:30,811 --> 00:04:32,950
Good.

113
00:04:32,950 --> 00:04:34,700
Another requirement
is to attend lectures.

114
00:04:34,700 --> 00:04:37,260
You're doing good
on that so far.

115
00:04:37,260 --> 00:04:42,860
And you'll have scribe-- I
would guess at this scale,

116
00:04:42,860 --> 00:04:45,340
you'll scribe once,
probably in a team.

117
00:04:45,340 --> 00:04:50,150
But we will figure that
out as time goes on.

118
00:04:50,150 --> 00:04:53,180
Again, they'll be email about
signing up for scribing.

119
00:04:53,180 --> 00:04:55,630
Scribing is taking
notes in the lecture

120
00:04:55,630 --> 00:04:58,142
so we have another
form of notes.

121
00:04:58,142 --> 00:04:59,600
There will be
something like five P

122
00:04:59,600 --> 00:05:01,220
sets every two to three weeks.

123
00:05:01,220 --> 00:05:05,450
The first one will go
out Tuesday is the plan.

124
00:05:05,450 --> 00:05:07,390
And then the big
part of the class

125
00:05:07,390 --> 00:05:11,210
is the project and presentation,
so the final project,

126
00:05:11,210 --> 00:05:13,360
you could do it on
almost anything related

127
00:05:13,360 --> 00:05:15,110
to the content of the class.

128
00:05:15,110 --> 00:05:18,870
Typical projects are do
something new theoretically,

129
00:05:18,870 --> 00:05:23,470
prove a problem hard, find
some nice open problems, survey

130
00:05:23,470 --> 00:05:26,620
existing material, something
that's not covered in class.

131
00:05:26,620 --> 00:05:27,900
You can code something.

132
00:05:27,900 --> 00:05:29,990
I think in this context,
the most natural thing

133
00:05:29,990 --> 00:05:32,860
to do is to visualize
cool proofs that we

134
00:05:32,860 --> 00:05:35,170
cover in class in a new way.

135
00:05:35,170 --> 00:05:36,890
You could contribute
to Wikipedia,

136
00:05:36,890 --> 00:05:38,870
or you could make
some art piece,

137
00:05:38,870 --> 00:05:40,850
like a sculpture,
or a performance,

138
00:05:40,850 --> 00:05:45,080
or whatever you want
related to hardness proofs.

139
00:05:45,080 --> 00:05:48,620
That's your project
possibilities.

140
00:05:48,620 --> 00:05:51,310
So what is in this class?

141
00:05:51,310 --> 00:05:55,940
I will look at what
specific topics are covered.

142
00:05:55,940 --> 00:05:57,320
This is on the website.

143
00:05:57,320 --> 00:05:59,500
So a lot of the class will
be about NP-completeness,

144
00:05:59,500 --> 00:06:02,440
which I will define in a bit.

145
00:06:02,440 --> 00:06:04,560
But we'll also look
at even harder--

146
00:06:04,560 --> 00:06:07,590
these are all notions of no
polynomial time algorithm.

147
00:06:07,590 --> 00:06:10,550
We'll do even harder notions
then NP, like PSPACE and X

148
00:06:10,550 --> 00:06:12,010
time, and so on.

149
00:06:12,010 --> 00:06:14,640
In particular, we'll be studying
those in the context of games

150
00:06:14,640 --> 00:06:17,750
and puzzles, and there's a whole
theory called games, puzzles,

151
00:06:17,750 --> 00:06:20,710
and computation, the
topic of this book,

152
00:06:20,710 --> 00:06:24,190
which we will talk
about at length.

153
00:06:24,190 --> 00:06:28,650
Then, we will go to
inapproximability.

154
00:06:28,650 --> 00:06:31,390
This is not necessarily in
order, so I should say then.

155
00:06:31,390 --> 00:06:34,340
But we'll talk about when you
cannot find good approximation

156
00:06:34,340 --> 00:06:37,490
algorithms, and what good means
depends on what sort of problem

157
00:06:37,490 --> 00:06:40,860
you're looking at, and when
you cannot find fixed parameter

158
00:06:40,860 --> 00:06:43,890
algorithms, which are fast
algorithms when the optimal

159
00:06:43,890 --> 00:06:46,570
solutions happens to be small.

160
00:06:46,570 --> 00:06:48,450
So that's all about
not polynomial.

161
00:06:48,450 --> 00:06:50,540
Then, there's a
small amount of work

162
00:06:50,540 --> 00:06:55,180
on understanding the polynomial
aspect for small polynomials,

163
00:06:55,180 --> 00:06:57,435
distinguishing almost
linear time from n

164
00:06:57,435 --> 00:06:59,590
squared time or n cubed time.

165
00:06:59,590 --> 00:07:00,925
That sort of thing.

166
00:07:00,925 --> 00:07:02,550
Then there are other
sorts of problems.

167
00:07:02,550 --> 00:07:04,714
We can think about less
common types of problems,

168
00:07:04,714 --> 00:07:06,880
like where you want to count
the number of solutions

169
00:07:06,880 --> 00:07:08,960
instead of just
find one, or tell

170
00:07:08,960 --> 00:07:10,850
whether the solution is unique.

171
00:07:10,850 --> 00:07:13,560
There's some economic
game theory stuff.

172
00:07:13,560 --> 00:07:15,220
This existential
theory, the reals,

173
00:07:15,220 --> 00:07:16,810
comes up in some
geometric settings.

174
00:07:16,810 --> 00:07:18,720
And if there's time,
we'll talk a little bit

175
00:07:18,720 --> 00:07:20,261
about undecidability,
although that's

176
00:07:20,261 --> 00:07:22,230
a pretty different world.

177
00:07:22,230 --> 00:07:25,250
That's where there's
no algorithm given

178
00:07:25,250 --> 00:07:28,630
any finite time bound.

179
00:07:28,630 --> 00:07:31,690
So that's in a nutshell
what's the entire class is.

180
00:07:31,690 --> 00:07:36,390
Today, we're going to do
a sort of crash course

181
00:07:36,390 --> 00:07:38,250
on computational complexity.

182
00:07:38,250 --> 00:07:41,780
Most of what you should need
for the entire course, I think,

183
00:07:41,780 --> 00:07:45,540
will fit in about 40 minutes.

184
00:07:45,540 --> 00:07:46,390
Maybe 50 minutes.

185
00:07:46,390 --> 00:07:47,150
Something.

186
00:07:47,150 --> 00:07:49,970
And that will serve
as a guideline.

187
00:07:49,970 --> 00:07:52,940
If anything's not clear, if I
go too fast, feel free to stop,

188
00:07:52,940 --> 00:07:57,110
ask questions during
class or after class.

189
00:07:57,110 --> 00:07:58,160
And let's see.

190
00:07:58,160 --> 00:08:02,860
So we have some-- there's no
real textbook for the class,

191
00:08:02,860 --> 00:08:05,550
but there are two
recommended reading books.

192
00:08:05,550 --> 00:08:08,220
They are Garey and Johnson.

193
00:08:08,220 --> 00:08:09,977
Computers and
Intractability is the title.

194
00:08:09,977 --> 00:08:11,560
Most people call it
Garey and Johnson.

195
00:08:11,560 --> 00:08:14,640
This is an old book
from pretty much

196
00:08:14,640 --> 00:08:16,350
early on in the world
of NP completeness,

197
00:08:16,350 --> 00:08:18,460
but it's still a
really good book.

198
00:08:18,460 --> 00:08:21,180
So that's good to check out.

199
00:08:21,180 --> 00:08:24,270
And then there's my
book with Bob Hearn.

200
00:08:24,270 --> 00:08:27,150
This is Bob Hearn's PhD
thesis at MIT, Games, Puzzles,

201
00:08:27,150 --> 00:08:28,190
and Computation.

202
00:08:28,190 --> 00:08:31,090
This is available
electronically for free online

203
00:08:31,090 --> 00:08:32,456
to all MIT people.

204
00:08:32,456 --> 00:08:34,039
So if you look it
up in MIT libraries,

205
00:08:34,039 --> 00:08:37,600
it's actually linked right here.

206
00:08:37,600 --> 00:08:38,819
So you're seeing that base.

207
00:08:38,819 --> 00:08:40,110
You can get an electronic copy.

208
00:08:40,110 --> 00:08:43,539
If you want to buy one,
talk to me or order it.

209
00:08:46,150 --> 00:08:48,420
There's a couple other
links on the website.

210
00:08:48,420 --> 00:08:51,000
There was some followup
to the Garey and Johnson

211
00:08:51,000 --> 00:08:56,800
book by Johnson and some
other cool websites.

212
00:08:56,800 --> 00:08:58,520
All right.

213
00:08:58,520 --> 00:09:02,180
So I think that is the
administrative part.

214
00:09:02,180 --> 00:09:04,430
Now we can start the
fun part of the class.

215
00:09:04,430 --> 00:09:10,449
So let's do our crash
course on complexity.

216
00:09:10,449 --> 00:09:12,490
So if you've seen complexity
before, some of this

217
00:09:12,490 --> 00:09:13,990
will be review.

218
00:09:13,990 --> 00:09:22,060
We start with our favorite
class of problems that can

219
00:09:22,060 --> 00:09:23,930
be solved in polynomial time.

220
00:09:35,490 --> 00:09:37,865
Say on a RAM, I should
specify model of computation

221
00:09:37,865 --> 00:09:39,640
and exactly what a
problem is, but I'll

222
00:09:39,640 --> 00:09:41,050
be a little bit informal here.

223
00:09:41,050 --> 00:09:46,190
Polynomial time means
n to some constant,

224
00:09:46,190 --> 00:09:50,670
where n is the size of
the problem instance.

225
00:09:50,670 --> 00:09:52,090
And we will talk
a little bit more

226
00:09:52,090 --> 00:09:53,840
about subtleties in defining n.

227
00:09:53,840 --> 00:09:57,270
But usually, polynomial
time is pretty clear.

228
00:09:57,270 --> 00:09:59,150
This is what we consider
good algorithms.

229
00:09:59,150 --> 00:10:01,370
An example of something
we consider bad

230
00:10:01,370 --> 00:10:02,700
is exponential time.

231
00:10:02,700 --> 00:10:04,940
So x is going to be all
the problems that can

232
00:10:04,940 --> 00:10:07,050
be solved in exponential time.

233
00:10:11,470 --> 00:10:15,590
And exponential's a little
less a uniquely defined,

234
00:10:15,590 --> 00:10:17,330
but I'll define it this way.

235
00:10:17,330 --> 00:10:20,000
I think this is the
usual definition for x. .

236
00:10:20,000 --> 00:10:22,222
So 2 to a polynomial.

237
00:10:22,222 --> 00:10:24,520
Of course, it could
be 3 if you prefer.

238
00:10:24,520 --> 00:10:26,370
Any constant will
be the same here.

239
00:10:26,370 --> 00:10:29,950
This constant dwarfs
any constant there.

240
00:10:29,950 --> 00:10:33,350
So that is-- this is a
huge class, any problem you

241
00:10:33,350 --> 00:10:34,640
can in exponential time.

242
00:10:34,640 --> 00:10:36,530
Most problems can be
solved exponential time,

243
00:10:36,530 --> 00:10:39,480
though not all.

244
00:10:39,480 --> 00:10:42,930
Most problems we
encounter, I should say.

245
00:10:42,930 --> 00:10:45,530
And then I'll define
one more just for kicks.

246
00:10:45,530 --> 00:10:47,820
R is a recursively
enumerable problems,

247
00:10:47,820 --> 00:10:49,169
or recursive problems.

248
00:10:49,169 --> 00:10:51,710
These are all the problems that
can be solved in finite time.

249
00:10:56,330 --> 00:10:56,930
Always.

250
00:10:56,930 --> 00:10:59,990
And these are all
worst case bounds.

251
00:10:59,990 --> 00:11:03,790
So I'm going to have
a running picture.

252
00:11:03,790 --> 00:11:07,820
This is my favorite
picture to draw.

253
00:11:07,820 --> 00:11:13,750
We have on the x-axis
a somewhat vague notion

254
00:11:13,750 --> 00:11:17,356
of computational difficulty.

255
00:11:17,356 --> 00:11:20,610
What you might call
hardness colloquially.

256
00:11:20,610 --> 00:11:23,680
This is a bit informal,
but it's still a useful way

257
00:11:23,680 --> 00:11:24,920
to think about things.

258
00:11:24,920 --> 00:11:28,140
So this initial
chunk here is going

259
00:11:28,140 --> 00:11:31,500
to be P. I'm going to
leave in some space

260
00:11:31,500 --> 00:11:33,440
to fill in some other things.

261
00:11:33,440 --> 00:11:36,410
And probably go to here.

262
00:11:36,410 --> 00:11:43,840
And this part is
going to be EXP,

263
00:11:43,840 --> 00:11:51,830
and then everything to
the left of this line

264
00:11:51,830 --> 00:11:54,040
are the problems that are
solvable in finite time.

265
00:11:54,040 --> 00:11:55,540
Everything to the
right of that line

266
00:11:55,540 --> 00:11:57,150
is not solvable by algorithms.

267
00:11:57,150 --> 00:11:58,413
That would be undecidable.

268
00:11:58,413 --> 00:11:59,320
OK.

269
00:11:59,320 --> 00:12:02,440
So obviously, anything
we saw in polynomial time

270
00:12:02,440 --> 00:12:04,120
can also be solved
in exponential time.

271
00:12:04,120 --> 00:12:06,910
That's all that this is saying.

272
00:12:06,910 --> 00:12:07,410
Cool.

273
00:12:07,410 --> 00:12:10,980
So I have examples.

274
00:12:10,980 --> 00:12:14,990
I'll give you some
examples to think about.

275
00:12:14,990 --> 00:12:20,010
For example, n by n Chess.

276
00:12:20,010 --> 00:12:22,630
So this is, I give you a Chess
configuration on an n by n,

277
00:12:22,630 --> 00:12:25,000
and I want to know,
let's say, white to move.

278
00:12:25,000 --> 00:12:28,600
Can white force a win?

279
00:12:28,600 --> 00:12:34,790
This turns out to be
solvable in exponential time,

280
00:12:34,790 --> 00:12:41,520
and is not solvable
in polynomial time.

281
00:12:41,520 --> 00:12:42,890
So that's a nice result.

282
00:12:42,890 --> 00:12:46,160
Something we will get to.

283
00:12:46,160 --> 00:12:52,020
Another example is Tetris,
suitably generalized.

284
00:12:52,020 --> 00:12:53,635
So we're thinking
about problems where

285
00:12:53,635 --> 00:12:54,680
you have all the information.

286
00:12:54,680 --> 00:12:56,410
Usually in Tetris, you
don't know all the pieces

287
00:12:56,410 --> 00:12:57,368
that are going to come.

288
00:12:57,368 --> 00:12:59,730
But supposing you knew
the future, I give you

289
00:12:59,730 --> 00:13:02,450
the entire sequence of pieces
that are going to come,

290
00:13:02,450 --> 00:13:03,520
sort of a Tetris puzzle.

291
00:13:03,520 --> 00:13:06,640
They used to publish these
in Nintendo Power Magazine.

292
00:13:06,640 --> 00:13:08,220
And you want to
know, can I survive

293
00:13:08,220 --> 00:13:09,340
from this board position?

294
00:13:09,340 --> 00:13:11,690
Can I survive this
sequence of pieces

295
00:13:11,690 --> 00:13:13,175
This is also in EXP.

296
00:13:13,175 --> 00:13:14,800
You can solve this
in exponential time.

297
00:13:14,800 --> 00:13:17,910
That's a little more obvious.

298
00:13:17,910 --> 00:13:23,940
But we don't know whether
it's in P. Probably it's not,

299
00:13:23,940 --> 00:13:25,320
and we'll see why in a moment.

300
00:13:31,140 --> 00:13:32,870
If you've taken an
algorithms class,

301
00:13:32,870 --> 00:13:34,480
you know tons of
examples of problems

302
00:13:34,480 --> 00:13:40,860
that are in P, like shortest
paths or lots of good things.

303
00:13:40,860 --> 00:13:45,790
Halting problem, you've
probably heard of.

304
00:13:45,790 --> 00:13:48,470
Kind of a classic.

305
00:13:48,470 --> 00:13:53,380
Halting problem is, given an
algorithm, does it terminate,

306
00:13:53,380 --> 00:13:55,780
or given some computer
code, does it terminate?

307
00:13:55,780 --> 00:13:58,450
This is not recursive,
meaning there's

308
00:13:58,450 --> 00:14:03,090
no algorithm to solve it in
finite time in the worst case.

309
00:14:03,090 --> 00:14:06,340
There's a more depressing
result, which is that in fact,

310
00:14:06,340 --> 00:14:18,930
most problems-- let's say most
decision problems are not in R.

311
00:14:18,930 --> 00:14:21,100
Most problems cannot be
solved by an algorithm.

312
00:14:21,100 --> 00:14:23,110
If you haven't seen
that, it's cool result.

313
00:14:23,110 --> 00:14:31,470
Basically, the proof is
that the number of problems

314
00:14:31,470 --> 00:14:36,050
in the universe is
about 2 to the N.

315
00:14:36,050 --> 00:14:39,430
And the number of
algorithms is only about N.

316
00:14:39,430 --> 00:14:41,020
So if you know
set theory, great.

317
00:14:41,020 --> 00:14:44,450
Otherwise, ignore this sentence.

318
00:14:44,450 --> 00:14:47,180
So you could think of an
algorithm as a number.

319
00:14:47,180 --> 00:14:49,220
It's like, you take this
string and convert it

320
00:14:49,220 --> 00:14:50,880
to a giant number.

321
00:14:50,880 --> 00:14:53,420
So that's integers over here.

322
00:14:53,420 --> 00:14:55,130
You can think of
problems as a mapping

323
00:14:55,130 --> 00:14:57,500
from inputs to Yes or No.

324
00:14:57,500 --> 00:14:58,810
Yes or No is the 2.

325
00:14:58,810 --> 00:15:03,172
Inputs is the N. This is
the same as real numbers.

326
00:15:03,172 --> 00:15:05,630
This is the integers, and there
are a lot more real numbers

327
00:15:05,630 --> 00:15:06,213
than integers.

328
00:15:06,213 --> 00:15:07,440
You probably heard of that.

329
00:15:07,440 --> 00:15:09,981
So this means most problems have
no algorithm if an algorithm

330
00:15:09,981 --> 00:15:11,780
can only solve one problem.

331
00:15:11,780 --> 00:15:13,070
That's the sad news of life.

332
00:15:13,070 --> 00:15:15,650
Luckily, most of the
problems we tend to pose

333
00:15:15,650 --> 00:15:18,975
do have an algorithm, and
it's more about P versus EXP

334
00:15:18,975 --> 00:15:21,920
that this class is about.

335
00:15:21,920 --> 00:15:25,210
So let's go to more
interesting things.

336
00:15:29,900 --> 00:15:35,560
I'm going to define a class
NP, which is in between here.

337
00:15:35,560 --> 00:15:36,680
In between P and EXP.

338
00:15:44,630 --> 00:15:46,470
So as I said, decision
problems are problems

339
00:15:46,470 --> 00:15:47,740
where the answer is Yes or No.

340
00:15:51,670 --> 00:15:53,690
There are lots of possible
definitions of NP.

341
00:15:53,690 --> 00:15:54,980
I will cover two.

342
00:15:58,629 --> 00:16:00,170
I would like there
to be an algorithm

343
00:16:00,170 --> 00:16:01,836
to solve the problem
in polynomial time,

344
00:16:01,836 --> 00:16:05,470
but not in a regular
model of computation,

345
00:16:05,470 --> 00:16:08,760
But with something I
call a lucky algorithm.

346
00:16:13,980 --> 00:16:16,500
Lucky algorithm
comes to a decision,

347
00:16:16,500 --> 00:16:19,504
and it always makes
the right one.

348
00:16:19,504 --> 00:16:20,170
It's just lucky.

349
00:16:20,170 --> 00:16:22,628
It doesn't have any reason to
believe that's the right one.

350
00:16:22,628 --> 00:16:25,390
It just always makes the
right choice given the choice

351
00:16:25,390 --> 00:16:27,940
between two options, let's say.

352
00:16:27,940 --> 00:16:30,335
So this is, you
make lucky guesses.

353
00:16:30,335 --> 00:16:33,810
You always guess the right one.

354
00:16:33,810 --> 00:16:36,630
It's a little bit biased
in a way that I should say.

355
00:16:36,630 --> 00:16:38,930
So let me be a
little more precise.

356
00:16:38,930 --> 00:16:43,310
This is called a
non-deterministic model.

357
00:16:43,310 --> 00:16:47,570
And the N in NP is
non-deterministic.

358
00:16:53,090 --> 00:16:56,240
So the idea is
that the algorithm

359
00:16:56,240 --> 00:16:57,330
makes a series of guesses.

360
00:16:57,330 --> 00:16:59,288
It could do it at the
beginning, or could do it

361
00:16:59,288 --> 00:17:01,710
in the middle of
the computation.

362
00:17:01,710 --> 00:17:06,190
And eventually, it
outputs an answer.

363
00:17:06,190 --> 00:17:10,930
So it's going to say
either Yes or No.

364
00:17:10,930 --> 00:17:14,589
And what we guarantee in this
weird non-deterministic lucky

365
00:17:14,589 --> 00:17:20,660
model of computation is that
you will be led to a Yes answer

366
00:17:20,660 --> 00:17:22,750
if it's possible.

367
00:17:22,750 --> 00:17:24,410
So it guesses--
this is asymmetric.

368
00:17:41,640 --> 00:17:44,250
So what this means is say
you run your magical lucky

369
00:17:44,250 --> 00:17:45,820
algorithm, and it outputs No.

370
00:17:45,820 --> 00:17:49,920
That means no matter
what set of choices

371
00:17:49,920 --> 00:17:53,876
you made for each guess, you
would always get to a No.

372
00:17:53,876 --> 00:17:55,250
If you get a Yes
answer, you just

373
00:17:55,250 --> 00:17:57,880
know there's some set of guesses
that lead to a Yes answer.

374
00:17:57,880 --> 00:18:01,520
So one is an existential
quantifier, one's universal.

375
00:18:01,520 --> 00:18:04,310
So this is asymmetric.

376
00:18:04,310 --> 00:18:09,430
There is a notion of CoNP,
which is exactly the reverse.

377
00:18:09,430 --> 00:18:14,010
CoNP, you let's say
flip Yes with No.

378
00:18:14,010 --> 00:18:18,460
So CoNP, you prefer no
answers if you can get them.

379
00:18:18,460 --> 00:18:19,680
All right.

380
00:18:19,680 --> 00:18:25,390
So let me give another
definition of NP.

381
00:18:48,434 --> 00:18:50,600
Another way to think of the
same definition, really.

382
00:19:16,350 --> 00:19:17,850
So you can also
think of NP problems

383
00:19:17,850 --> 00:19:21,300
as problems that have solutions
that are relatively succinct

384
00:19:21,300 --> 00:19:23,490
and can be checked
in polynomial time.

385
00:19:23,490 --> 00:19:27,460
I guess really they need to
be checkable efficiently.

386
00:19:27,460 --> 00:19:31,070
So what you can think
of this as saying is,

387
00:19:31,070 --> 00:19:32,730
well, every time I
make a guess, I'll

388
00:19:32,730 --> 00:19:36,560
write down whether I went
left or went right in my maze,

389
00:19:36,560 --> 00:19:37,950
I guess.

390
00:19:37,950 --> 00:19:40,600
And so that you could
think of as a certificate.

391
00:19:40,600 --> 00:19:42,910
If you know what the right
sequence of guesses are,

392
00:19:42,910 --> 00:19:44,451
of course, you can
run the algorithm,

393
00:19:44,451 --> 00:19:46,790
because it's a polynomial
time algorithm.

394
00:19:46,790 --> 00:19:51,900
Conversely, if I don't have
the solution to the problem,

395
00:19:51,900 --> 00:19:55,070
yet I'm told that it exists,
at the top of my algorithm,

396
00:19:55,070 --> 00:19:58,470
I could just guess what that
solution is, and then check it.

397
00:19:58,470 --> 00:19:59,940
So if I'm given
such an algorithm,

398
00:19:59,940 --> 00:20:01,770
I can convert it into
a lucky algorithm.

399
00:20:01,770 --> 00:20:03,270
If I'm given a
lucky algorithm, I

400
00:20:03,270 --> 00:20:06,650
can convert it into one of
these checking algorithms.

401
00:20:06,650 --> 00:20:07,150
OK.

402
00:20:10,080 --> 00:20:13,275
So let's do an example.

403
00:20:18,170 --> 00:20:22,880
Let's say Tetris is in NP.

404
00:20:22,880 --> 00:20:28,070
So if I give you a board, and
I give you a sequence of pieces

405
00:20:28,070 --> 00:20:29,320
that are going to come.

406
00:20:29,320 --> 00:20:31,270
How would I prove to
you that I can survive

407
00:20:31,270 --> 00:20:32,311
those sequence of pieces?

408
00:20:34,840 --> 00:20:36,330
AUDIENCE: Say where they go?

409
00:20:36,330 --> 00:20:37,746
PROFESSOR: Just
say where they go.

410
00:20:37,746 --> 00:20:41,960
Say what sequence or moves I
press, and at what times say.

411
00:20:41,960 --> 00:20:44,560
Just where should
I drop each piece?

412
00:20:44,560 --> 00:20:47,230
So then all you need to do
for this definition is check

413
00:20:47,230 --> 00:20:49,219
that that's about
solution that you never

414
00:20:49,219 --> 00:20:50,760
have to push a piece
up, for example,

415
00:20:50,760 --> 00:20:55,100
to get it into the
right position.

416
00:20:55,100 --> 00:20:57,180
Or you can think
of the same thing

417
00:20:57,180 --> 00:20:58,910
as an algorithm
that says, oh, OK.

418
00:20:58,910 --> 00:21:01,590
Every time I have to press left,
or right, or wait a second,

419
00:21:01,590 --> 00:21:03,350
or push down, I'll
just guess which

420
00:21:03,350 --> 00:21:05,330
one to do, and then do that.

421
00:21:05,330 --> 00:21:09,570
So these are the same
algorithm, essentially.

422
00:21:09,570 --> 00:21:11,260
And that's why Tetris is in NP.

423
00:21:11,260 --> 00:21:13,870
In general, let's see.

424
00:21:13,870 --> 00:21:17,250
Every problem that I can
solve in polynomial time,

425
00:21:17,250 --> 00:21:19,730
of course, I can solve in
non-deterministic polynomial

426
00:21:19,730 --> 00:21:21,970
time, so that's
that containment.

427
00:21:21,970 --> 00:21:24,010
If I have an NP
problem and I want

428
00:21:24,010 --> 00:21:26,430
to solve it in
exponential time, well, I

429
00:21:26,430 --> 00:21:29,090
could just simulate all the
possible guessing paths,

430
00:21:29,090 --> 00:21:31,530
because I run for
only polynomial time.

431
00:21:31,530 --> 00:21:33,889
And so for each one,
maybe I have two choices.

432
00:21:33,889 --> 00:21:34,680
I'll just try both.

433
00:21:34,680 --> 00:21:36,640
I'll do this sort
of depth research.

434
00:21:36,640 --> 00:21:39,290
And yeah.

435
00:21:39,290 --> 00:21:42,390
I have exponential is
exactly 2 to that polynomial,

436
00:21:42,390 --> 00:21:45,330
so I can afford to branch
in both directions.

437
00:21:45,330 --> 00:21:47,490
So I guess my guesses
here are just binary.

438
00:21:47,490 --> 00:21:49,560
I could afford to branch
in both directions,

439
00:21:49,560 --> 00:21:52,394
and eventually see whether
any of them leads to a Yes.

440
00:21:52,394 --> 00:21:54,810
I could also figure out whether
any of them leads to a No.

441
00:21:54,810 --> 00:21:58,780
But in general, NP
is contained in EXP.

442
00:21:58,780 --> 00:22:01,400
Cool.

443
00:22:01,400 --> 00:22:03,995
Still not too interesting.

444
00:22:06,295 --> 00:22:07,670
Where it gets
interesting is when

445
00:22:07,670 --> 00:22:10,400
we start talking about
hardness, which is next.

446
00:22:10,400 --> 00:22:15,340
I should mention big open
question is whether there's

447
00:22:15,340 --> 00:22:18,400
any problem in
here in NP minus P.

448
00:22:18,400 --> 00:22:21,020
This is the same as P
equals NP open problem.

449
00:22:21,020 --> 00:22:26,140
Most sane people in the universe
believe P does not equal NP.

450
00:22:26,140 --> 00:22:32,570
What this means intuitively is
that you can't engineer luck.

451
00:22:32,570 --> 00:22:35,610
Luck shouldn't exist
in the real world.

452
00:22:35,610 --> 00:22:38,606
You can't just like,
go one way or the other

453
00:22:38,606 --> 00:22:39,980
and always make
the right choice.

454
00:22:39,980 --> 00:22:41,570
You could make a random choice.

455
00:22:41,570 --> 00:22:43,446
You could try both choices.

456
00:22:43,446 --> 00:22:45,820
But you shouldn't be able to
always make the right choice

457
00:22:45,820 --> 00:22:46,810
for all problems.

458
00:22:46,810 --> 00:22:48,099
That seems insane.

459
00:22:48,099 --> 00:22:50,390
So if you believe that, you
believe P does not equal NP

460
00:22:50,390 --> 00:22:52,920
and you believe there's some
things in between those two

461
00:22:52,920 --> 00:22:53,420
lines.

462
00:22:53,420 --> 00:22:56,820
But we don't know,
unfortunately.

463
00:22:56,820 --> 00:23:03,250
So let me talk about hardness.

464
00:23:03,250 --> 00:23:06,063
So if I have some
complexity class X,

465
00:23:06,063 --> 00:23:11,540
X could be NP, or
EXP at this point.

466
00:23:11,540 --> 00:23:12,662
P we won't talk about.

467
00:23:12,662 --> 00:23:13,870
P hardness is a little weird.

468
00:23:17,457 --> 00:23:19,790
I'm not going to define this
formally until a little bit

469
00:23:19,790 --> 00:23:21,760
later in today's class.

470
00:23:28,670 --> 00:23:31,270
So problem is X-hard if
it's sort of the hardest

471
00:23:31,270 --> 00:23:35,540
problem in the class X, if it's
as hard as every other problem

472
00:23:35,540 --> 00:23:38,970
in X. Actually, this
problem may not be in X,

473
00:23:38,970 --> 00:23:42,700
so I should say it's hard
as every problem in X.

474
00:23:42,700 --> 00:23:51,030
So what that means in this
picture is the following.

475
00:23:54,510 --> 00:23:58,380
So every problem from
here onward is EXP-hard.

476
00:24:02,880 --> 00:24:08,130
And every problem from
here onward is NP-hard.

477
00:24:12,090 --> 00:24:13,760
Whoops.

478
00:24:13,760 --> 00:24:16,259
Here.

479
00:24:16,259 --> 00:24:17,550
We won't talk about P hardness.

480
00:24:17,550 --> 00:24:20,505
That's a notion in
parallel computing.

481
00:24:20,505 --> 00:24:22,620
I mean, maybe we'll have
time to talk about it,

482
00:24:22,620 --> 00:24:24,920
but it's not
currently on the plan.

483
00:24:24,920 --> 00:24:28,517
So this is the lower
bound side, right?

484
00:24:28,517 --> 00:24:30,100
You're proving that
you're at least as

485
00:24:30,100 --> 00:24:32,790
hard as the very
hardest problem in NP,

486
00:24:32,790 --> 00:24:36,590
or you're at least as hard
as the problem in EXP.

487
00:24:36,590 --> 00:24:43,510
The reason, the only reason,
I know that Chess is not NP

488
00:24:43,510 --> 00:24:47,250
is because I know that
Chess is actually X-hard.

489
00:24:47,250 --> 00:24:49,830
I know it's at least as hard
as all problems solvable

490
00:24:49,830 --> 00:24:51,110
an exponential time.

491
00:24:51,110 --> 00:24:54,510
And there's a great theorem
called time hierarchy theorem

492
00:24:54,510 --> 00:24:58,000
that tells you that P does
not equal EXP in particular.

493
00:24:58,000 --> 00:25:01,090
So we know there are
some problems in EXP that

494
00:25:01,090 --> 00:25:04,200
are not in P. Some problems that
require exponential time can't

495
00:25:04,200 --> 00:25:05,940
be done in polynomial time.

496
00:25:05,940 --> 00:25:08,420
And we know that Chess is
as hard as all of them,

497
00:25:08,420 --> 00:25:12,882
so in particular, it also can't
be solved in polynomial time.

498
00:25:12,882 --> 00:25:15,340
Mind you, though, I haven't
defined what as hard as a means

499
00:25:15,340 --> 00:25:19,320
yet, but I will get there.

500
00:25:19,320 --> 00:25:23,680
Another good term to
know is X-completeness.

501
00:25:23,680 --> 00:25:29,090
This is just the and of two
things, being X-hard and being

502
00:25:29,090 --> 00:25:39,810
in X. So in my picture, this
dot right here is NP-complete.

503
00:25:44,080 --> 00:25:47,920
And this dot right here
is-- got to write it

504
00:25:47,920 --> 00:25:50,120
this way-- is X-complete.

505
00:25:55,671 --> 00:25:56,170
OK.

506
00:25:56,170 --> 00:25:58,330
I already mentioned
that Chess is in EXP.

507
00:25:58,330 --> 00:26:00,920
So in fact, Chess is X-complete.

508
00:26:00,920 --> 00:26:03,420
It means there's an upper bound
saying that you can solve it

509
00:26:03,420 --> 00:26:04,277
in exponential time.

510
00:26:04,277 --> 00:26:06,360
There's a lower bound
saying that it's at least as

511
00:26:06,360 --> 00:26:07,926
hard as everything in EXP.

512
00:26:07,926 --> 00:26:10,550
And both are true, so you would
know you're kind of right here.

513
00:26:10,550 --> 00:26:12,770
From the resolution
of this picture,

514
00:26:12,770 --> 00:26:15,010
that's all you could
hope to know about Chess.

515
00:26:18,360 --> 00:26:21,310
So, good.

516
00:26:24,350 --> 00:26:28,120
One more class of problems
good to know about,

517
00:26:28,120 --> 00:26:34,870
and it will come up a lot in
games, is the notion of PSPACE.

518
00:26:34,870 --> 00:26:36,690
So so far, we've only
thought about time.

519
00:26:36,690 --> 00:26:38,140
But usually, we
measure algorithms

520
00:26:38,140 --> 00:26:39,300
in terms of time and space.

521
00:26:39,300 --> 00:26:42,520
How much memory does
your algorithm use?

522
00:26:42,520 --> 00:26:49,005
And so PSPACE is going to be, I
guess, say let's say problems.

523
00:26:58,185 --> 00:27:00,060
As you might guess, this
is problems solvable

524
00:27:00,060 --> 00:27:03,060
in polynomial space.

525
00:27:03,060 --> 00:27:05,560
In general, if you can solve
a problem in polynomial space,

526
00:27:05,560 --> 00:27:07,941
you can solve it in
exponential time,

527
00:27:07,941 --> 00:27:09,940
because there are only
exponentially many states

528
00:27:09,940 --> 00:27:12,600
of your machine if you
only have polynomial space.

529
00:27:12,600 --> 00:27:20,320
So PSPACE fits here
in between NP and EXP.

530
00:27:23,210 --> 00:27:34,154
And of course, there's
PSPACE-hard and

531
00:27:34,154 --> 00:27:34,820
PSPACE-complete.

532
00:27:41,190 --> 00:27:43,340
If you don't remember
anything from today

533
00:27:43,340 --> 00:27:46,740
except one blackboard,
remember this blackboard.

534
00:27:46,740 --> 00:27:49,590
It's like the cheat sheet
to everything we've defined.

535
00:27:49,590 --> 00:27:53,040
You just have to remember
what all the letters mean.

536
00:27:53,040 --> 00:27:54,670
But not too hard.

537
00:27:54,670 --> 00:27:57,350
So that's pretty much all
the classes we'll be using.

538
00:27:57,350 --> 00:27:59,060
There are a few others.

539
00:27:59,060 --> 00:27:59,560
I'm sorry.

540
00:27:59,560 --> 00:28:03,190
I'll give you one example to
go with our other examples.

541
00:28:03,190 --> 00:28:05,870
The problem we'll look
at today is Rush Hour.

542
00:28:08,750 --> 00:28:10,456
This is a one
player puzzle, where

543
00:28:10,456 --> 00:28:12,580
you're trying to move the
cars, and they could only

544
00:28:12,580 --> 00:28:15,210
go vertically or horizontally.

545
00:28:15,210 --> 00:28:21,110
This is in PSPACE, which
is maybe not so obvious.

546
00:28:21,110 --> 00:28:25,510
And actually, it's
PSPACE-complete.

547
00:28:25,510 --> 00:28:32,570
So this is from the
diagram, PSPACE-complete

548
00:28:32,570 --> 00:28:34,787
is harder than NP-complete.

549
00:28:34,787 --> 00:28:37,370
Now of course, we don't actually
know whether these two points

550
00:28:37,370 --> 00:28:38,904
are the same.

551
00:28:38,904 --> 00:28:39,820
It's kind of annoying.

552
00:28:39,820 --> 00:28:42,014
We don't know whether these
two points are the same.

553
00:28:42,014 --> 00:28:44,180
We don't know whether these
two points are the same.

554
00:28:44,180 --> 00:28:45,801
This whole thing could collapse.

555
00:28:45,801 --> 00:28:47,550
We do know these two
points are different.

556
00:28:47,550 --> 00:28:51,890
So somewhere here, or here, or
here, we have a positive range.

557
00:28:51,890 --> 00:28:56,109
Most people believe all of
these have problems in them,

558
00:28:56,109 --> 00:28:57,650
so none of these
things are the same.

559
00:28:57,650 --> 00:28:59,941
It could be NP-complete is
the same as PSPACE-complete.

560
00:28:59,941 --> 00:29:02,960
But again, most people
believe these are different.

561
00:29:02,960 --> 00:29:05,880
So in some sense, Rush
Hour, which is here,

562
00:29:05,880 --> 00:29:07,520
is harder than
Tetris, which is here.

563
00:29:10,730 --> 00:29:11,590
Cool.

564
00:29:11,590 --> 00:29:16,780
And if you believe that either
one of these is non-empty,

565
00:29:16,780 --> 00:29:19,460
then we know that Rush Hour
does not have a polynomial time

566
00:29:19,460 --> 00:29:19,960
algorithm.

567
00:29:19,960 --> 00:29:23,679
So to show that Rush Hour is
not in P, you have a choice.

568
00:29:23,679 --> 00:29:25,720
You could prove either
one of these as non-empty.

569
00:29:25,720 --> 00:29:28,050
For Tetris, you have
to prove this one.

570
00:29:28,050 --> 00:29:30,690
So you'd be less famous
if you prove this one.

571
00:29:30,690 --> 00:29:33,190
Still pretty famous, but you
wouldn't win the million dollar

572
00:29:33,190 --> 00:29:34,650
bounty that's on P versus NP.

573
00:29:37,380 --> 00:29:38,500
All right.

574
00:29:38,500 --> 00:29:40,735
There are bigger classes.

575
00:29:40,735 --> 00:29:42,110
We talked about
exponential time.

576
00:29:42,110 --> 00:29:44,282
You can, of course, talk
about exponential space.

577
00:29:44,282 --> 00:29:45,490
In general, these interleave.

578
00:29:45,490 --> 00:29:48,350
You go polynomial
time, polynomial space,

579
00:29:48,350 --> 00:29:51,440
exponential time, exponential
space, doubly exponential time,

580
00:29:51,440 --> 00:29:53,410
doubly exponential
space, and so on.

581
00:29:53,410 --> 00:29:57,280
That's the order in
which they occur.

582
00:29:57,280 --> 00:30:00,090
The only things we know
is that polynomial time is

583
00:30:00,090 --> 00:30:01,520
different from
exponential time is

584
00:30:01,520 --> 00:30:03,144
different from doubly
exponential time,

585
00:30:03,144 --> 00:30:05,460
or any function of time, really.

586
00:30:05,460 --> 00:30:07,860
And we know that
polynomial space

587
00:30:07,860 --> 00:30:10,360
is different from exponential
space is different from doubly

588
00:30:10,360 --> 00:30:11,510
exponential space.

589
00:30:11,510 --> 00:30:13,218
But we don't know
about the interrelation

590
00:30:13,218 --> 00:30:14,280
between time and space.

591
00:30:14,280 --> 00:30:16,460
That's one of the big questions.

592
00:30:16,460 --> 00:30:18,640
The other big question
is non-determinism.

593
00:30:18,640 --> 00:30:25,300
One fun fact you should know
is that PSPACE equals NPSPACE.

594
00:30:25,300 --> 00:30:28,420
This is a useful fact.

595
00:30:28,420 --> 00:30:31,830
NPSPACE is non-deterministic
polynomial space.

596
00:30:31,830 --> 00:30:33,806
So you take a lucky
algorithm, and you

597
00:30:33,806 --> 00:30:35,430
don't guarantee how
much time it takes,

598
00:30:35,430 --> 00:30:37,134
it will be a most
exponential time.

599
00:30:37,134 --> 00:30:39,050
You only guarantee the
amount of space it uses

600
00:30:39,050 --> 00:30:42,180
is, at most, polynomial.

601
00:30:42,180 --> 00:30:44,450
This is a theorem
called Savages Theorem,

602
00:30:44,450 --> 00:30:45,826
and it works for
any space bound.

603
00:30:45,826 --> 00:30:47,366
In general, the
space bound, I think,

604
00:30:47,366 --> 00:30:49,070
grows to the square
of its original,

605
00:30:49,070 --> 00:30:50,960
if you want to convert
non-deterministic

606
00:30:50,960 --> 00:30:51,980
to deterministic.

607
00:30:51,980 --> 00:30:55,191
This is useful for Rush Hour,
because to play a Rush Hour

608
00:30:55,191 --> 00:30:57,690
game, in general, the number
of moves you might have to make

609
00:30:57,690 --> 00:31:00,930
is exponential, so
it's not obviously

610
00:31:00,930 --> 00:31:03,020
in NP, because NP
would have to have

611
00:31:03,020 --> 00:31:05,200
a short polynomial-length
solution that you

612
00:31:05,200 --> 00:31:08,430
can check in polynomial time.

613
00:31:08,430 --> 00:31:10,726
But Rush Hour, you can
solve in polynomial space

614
00:31:10,726 --> 00:31:12,600
if you're really lucky
because you say, well,

615
00:31:12,600 --> 00:31:13,190
what move should I make?

616
00:31:13,190 --> 00:31:15,449
Well, I'll guess one,
then I'll make that move.

617
00:31:15,449 --> 00:31:16,240
Guess another move.

618
00:31:16,240 --> 00:31:17,190
Make the move.

619
00:31:17,190 --> 00:31:19,650
And just maintaining
the state of the board

620
00:31:19,650 --> 00:31:21,740
only takes polynomial space.

621
00:31:21,740 --> 00:31:24,630
So then if you solve
it, you're happy.

622
00:31:24,630 --> 00:31:27,660
If there's no way to solve
it, you will return No.

623
00:31:27,660 --> 00:31:29,150
I guess you have a timer.

624
00:31:29,150 --> 00:31:30,970
After you've made
exponentially many moves,

625
00:31:30,970 --> 00:31:33,790
if you still haven't solved
the puzzle, you can return No.

626
00:31:33,790 --> 00:31:35,960
And in the lucky
world, that means

627
00:31:35,960 --> 00:31:38,270
you will find a solution
if there is one.

628
00:31:38,270 --> 00:31:39,730
Conveniently, lucky
algorithms can

629
00:31:39,730 --> 00:31:41,860
be turned into
regular algorithms

630
00:31:41,860 --> 00:31:43,940
when you're only worried
about space bounds.

631
00:31:43,940 --> 00:31:47,730
And so that's how you prove
Rush Hour is in PSPACE.

632
00:31:47,730 --> 00:31:49,400
So that's a good fact to know.

633
00:31:52,130 --> 00:31:53,630
Cool.

634
00:31:53,630 --> 00:31:54,130
All right.

635
00:31:54,130 --> 00:31:56,910
There's one key thing
we haven't defined yet,

636
00:31:56,910 --> 00:31:59,220
which is as hard as.

637
00:31:59,220 --> 00:32:01,030
So let's get to that.

638
00:32:01,030 --> 00:32:05,669
This is really the
heart of the class.

639
00:32:05,669 --> 00:32:06,460
Let me go up there.

640
00:32:41,230 --> 00:32:44,910
So this class is really
all about one notion,

641
00:32:44,910 --> 00:32:47,040
and that notion is reductions.

642
00:32:47,040 --> 00:32:49,712
So if I have two
problems A and B, then

643
00:32:49,712 --> 00:32:51,670
there's this notion of
a reduction from A to B.

644
00:32:51,670 --> 00:32:53,740
This will be an algorithm.

645
00:32:53,740 --> 00:32:56,480
For us, almost all the time
it will be a polynomial time

646
00:32:56,480 --> 00:32:59,740
algorithm, although you could
put in a different adjective

647
00:32:59,740 --> 00:33:01,265
here than polynomial time.

648
00:33:01,265 --> 00:33:02,890
Most of the time,
that is what we want.

649
00:33:12,070 --> 00:33:16,480
And it's going to convert an
instance of the A problem--

650
00:33:16,480 --> 00:33:21,160
so instance just means
input-- and we'll

651
00:33:21,160 --> 00:33:23,190
convert it into an
instance of the B problem.

652
00:33:26,880 --> 00:33:35,770
And it's going to do so in a
way such that the solution to A

653
00:33:35,770 --> 00:33:42,410
equals the solution
to B. I mean,

654
00:33:42,410 --> 00:33:45,100
the solution of
that instance of A

655
00:33:45,100 --> 00:33:48,190
is the same as the solution
of the instance to B.

656
00:33:48,190 --> 00:33:50,760
So this is-- think
decision problems.

657
00:33:50,760 --> 00:33:53,085
The answer's either Yes or No.

658
00:33:53,085 --> 00:33:56,910
So we want to convert A into
an equivalent instance of B,

659
00:33:56,910 --> 00:34:00,130
equivalent meaning that
it has the same answer.

660
00:34:00,130 --> 00:34:01,300
Why do we care?

661
00:34:01,300 --> 00:34:07,890
Because let's suppose we
had an algorithm to solve B.

662
00:34:07,890 --> 00:34:09,120
That would be this arrow.

663
00:34:09,120 --> 00:34:16,870
So let's say if we
can solve B, then

664
00:34:16,870 --> 00:34:20,380
we can solve A by this diagram.

665
00:34:20,380 --> 00:34:23,969
Take an instance of A, convert
it into an equivalence of B,

666
00:34:23,969 --> 00:34:27,650
solve B, and then that solution
is equal to the solution to A,

667
00:34:27,650 --> 00:34:37,300
so we solved A.

668
00:34:37,300 --> 00:34:39,070
This is as hard as.

669
00:34:39,070 --> 00:34:51,550
So what we say is
B is as hard as A.

670
00:34:51,550 --> 00:34:54,400
That's a definition
of this hardness.

671
00:34:54,400 --> 00:34:56,929
In general, depending on
your definition of reduction,

672
00:34:56,929 --> 00:34:58,762
you'll get a different
notion of as hard as,

673
00:34:58,762 --> 00:35:02,680
but we will stick primarily
to polynomial time.

674
00:35:02,680 --> 00:35:04,120
Reductions.

675
00:35:04,120 --> 00:35:08,944
This is what you might
call a one call reduction.

676
00:35:08,944 --> 00:35:10,235
This is kind of a technicality.

677
00:35:13,690 --> 00:35:15,990
Also called a Karp
style reduction

678
00:35:15,990 --> 00:35:23,190
because Karp gave a whole bunch
of them in the '70s, '80s.

679
00:35:23,190 --> 00:35:27,120
So the idea is you only get to
call your solution to be once.

680
00:35:27,120 --> 00:35:29,330
In general, you could imagine
an algorithm that calls

681
00:35:29,330 --> 00:35:31,330
your solution to be many times.

682
00:35:31,330 --> 00:35:33,750
That would also be a
notion of as hard as.

683
00:35:33,750 --> 00:35:38,022
For the problems we'll look,
basically, these two notions

684
00:35:38,022 --> 00:35:39,480
don't seem very
helpful, let's say.

685
00:35:39,480 --> 00:35:41,040
So we'll stick to
one call reductions

686
00:35:41,040 --> 00:35:44,190
because they seem
sufficient for everything

687
00:35:44,190 --> 00:35:45,580
that we will cover
in this class.

688
00:35:45,580 --> 00:35:46,160
Probably.

689
00:35:46,160 --> 00:35:47,826
Maybe in some very
late lecture, we'll

690
00:35:47,826 --> 00:35:49,200
talk about multi-call
reductions.

691
00:35:49,200 --> 00:35:50,630
But they're not so prominent.

692
00:35:50,630 --> 00:35:54,480
One call reductions are the
bread and butter of hardness.

693
00:35:54,480 --> 00:35:57,700
So as you might imagine, this
is how you prove a problem hard.

694
00:35:57,700 --> 00:36:04,060
Basically, all hardness
proofs in the known universe

695
00:36:04,060 --> 00:36:05,540
are based on a reduction.

696
00:36:05,540 --> 00:36:07,061
You start from a
problem which you

697
00:36:07,061 --> 00:36:10,050
know is hard in whatever
class you care about,

698
00:36:10,050 --> 00:36:12,830
and you reduce from that
problem, the known hard

699
00:36:12,830 --> 00:36:15,840
problem, to your problem
that you're not sure about.

700
00:36:15,840 --> 00:36:17,930
If you can do that,
then you prove

701
00:36:17,930 --> 00:36:20,870
that your problem is as hard
as the original problem.

702
00:36:20,870 --> 00:36:23,460
If you know that one is
hard, than this one is hard.

703
00:36:23,460 --> 00:36:26,340
Don't get this backwards.

704
00:36:26,340 --> 00:36:29,230
You will anyway, but try
not to get it backwards.

705
00:36:29,230 --> 00:36:32,640
You're always reducing
from the known hard problem

706
00:36:32,640 --> 00:36:34,201
to your problem.

707
00:36:34,201 --> 00:36:34,700
OK.

708
00:36:34,700 --> 00:36:37,010
So usually say,
our proof is based

709
00:36:37,010 --> 00:36:39,860
on a reduction from-- pick
your favorite problem.

710
00:36:39,860 --> 00:36:41,220
Never two.

711
00:36:41,220 --> 00:36:45,420
Easy to get wrong, because
it's easy to make a sign error.

712
00:36:45,420 --> 00:36:46,340
But that's life.

713
00:36:46,340 --> 00:36:49,780
So good.

714
00:36:49,780 --> 00:36:51,260
Anything else?

715
00:36:51,260 --> 00:36:53,009
Now if you've taken
an algorithms class,

716
00:36:53,009 --> 00:36:54,300
you've seen lots of reductions.

717
00:36:54,300 --> 00:36:57,170
Reductions are a powerful
tool in algorithms too.

718
00:36:57,170 --> 00:37:01,510
For example, some
lame examples like,

719
00:37:01,510 --> 00:37:04,000
if you have an unweighted
shortest path problem,

720
00:37:04,000 --> 00:37:07,799
you can reduce that to a
weighted shortest path problem.

721
00:37:07,799 --> 00:37:08,590
How do you do that?

722
00:37:08,590 --> 00:37:09,798
You set all the weights to 1.

723
00:37:09,798 --> 00:37:11,180
Yay.

724
00:37:11,180 --> 00:37:12,130
Why would you do that?

725
00:37:12,130 --> 00:37:12,838
Well, never mind.

726
00:37:16,170 --> 00:37:18,180
It kind of illustrates
what's going on here.

727
00:37:18,180 --> 00:37:22,100
What we're showing is
that A is a special case

728
00:37:22,100 --> 00:37:24,750
of B. Unweighted shortest
paths is a special case

729
00:37:24,750 --> 00:37:26,070
of weighted shortest paths.

730
00:37:26,070 --> 00:37:28,250
In some sense, all
reductions are that,

731
00:37:28,250 --> 00:37:30,010
but they're usually
much less obvious

732
00:37:30,010 --> 00:37:32,620
than unweighted shortest paths
to weighted shortest paths.

733
00:37:32,620 --> 00:37:34,250
And the reason we
can say B is as hard

734
00:37:34,250 --> 00:37:37,734
as A is because [? modular ?]
this conversion algorithm

735
00:37:37,734 --> 00:37:40,320
A is a special case
of B. So of course,

736
00:37:40,320 --> 00:37:42,870
if B has more cases than
A, or maybe the same,

737
00:37:42,870 --> 00:37:45,550
but if it has at least as many
cases as A, then of course,

738
00:37:45,550 --> 00:37:46,950
B is at at least
as hard to solve

739
00:37:46,950 --> 00:37:50,000
as A in this formal sense.

740
00:37:50,000 --> 00:37:51,290
OK.

741
00:37:51,290 --> 00:37:52,130
Cool.

742
00:37:52,130 --> 00:37:53,140
There are more
interesting examples

743
00:37:53,140 --> 00:37:54,681
you've probably seen
in problem sets,

744
00:37:54,681 --> 00:37:58,250
like if you want in
the arbitrage problem,

745
00:37:58,250 --> 00:38:01,910
you want to find a path that
has the minimum product of all

746
00:38:01,910 --> 00:38:04,215
the values, to convert
products into a min.

747
00:38:04,215 --> 00:38:06,340
Some problem, you just take
logs of all the values.

748
00:38:06,340 --> 00:38:08,930
So the reduction is compute
logs and all the weights.

749
00:38:08,930 --> 00:38:11,630
So you've probably seen
lots of things like that.

750
00:38:11,630 --> 00:38:15,310
Some are more
complicated than others.

751
00:38:15,310 --> 00:38:19,830
What we're going to do in
this class is reduce instead

752
00:38:19,830 --> 00:38:22,540
of-- so for algorithms, you
want to reduce to something

753
00:38:22,540 --> 00:38:24,330
you know how to solve.

754
00:38:24,330 --> 00:38:26,120
We're going to
reduce from something

755
00:38:26,120 --> 00:38:28,940
we know we can't solve
under certain assumptions.

756
00:38:28,940 --> 00:38:32,880
So assuming P does not
equal NP, if A is NP-hard

757
00:38:32,880 --> 00:38:38,820
and we reduce from A to B,
then we know the B is NP-hard.

758
00:38:38,820 --> 00:38:40,820
That's a theorem.

759
00:38:40,820 --> 00:38:45,700
So in this situation,
if we have a reduction,

760
00:38:45,700 --> 00:38:49,980
let's say if A reduces
to B, I'll be explicit,

761
00:38:49,980 --> 00:38:54,857
and A-- better get this right.

762
00:38:54,857 --> 00:38:56,940
It would be pretty
embarrassing if I got it wrong,

763
00:38:56,940 --> 00:39:00,020
but I probably will get it wrong
at some point in this class.

764
00:39:00,020 --> 00:39:02,340
Hopefully not today.

765
00:39:02,340 --> 00:39:04,660
Then B is X-hard.

766
00:39:07,010 --> 00:39:07,510
OK.

767
00:39:07,510 --> 00:39:09,790
That's actually kind
of a trivial theorem

768
00:39:09,790 --> 00:39:11,454
if you read all the definitions.

769
00:39:11,454 --> 00:39:12,120
What did X-hard?

770
00:39:12,120 --> 00:39:16,170
It meant as hard as
every problem in X.

771
00:39:16,170 --> 00:39:19,470
And as hard as meant
there was a reduction.

772
00:39:19,470 --> 00:39:22,080
So that means-- get
this right-- there's

773
00:39:22,080 --> 00:39:26,640
reduction from every problem
in X to your problem.

774
00:39:26,640 --> 00:39:28,570
So if A is NP-hard
there's a reduction

775
00:39:28,570 --> 00:39:30,780
from every problem
to A, and we're

776
00:39:30,780 --> 00:39:33,330
saying now what if there's
also a reduction from A to B,

777
00:39:33,330 --> 00:39:34,746
well then, we can
just chain those

778
00:39:34,746 --> 00:39:37,820
are two reductions together,
convert any problem in X to A,

779
00:39:37,820 --> 00:39:41,050
then convert it to B. And so
we've shown every problem in X

780
00:39:41,050 --> 00:39:44,480
can be reduced to B,
where B is X-hard.

781
00:39:44,480 --> 00:39:46,920
This is an easy theorem.

782
00:39:46,920 --> 00:39:51,240
The converse would be if B
can be solved in class X,

783
00:39:51,240 --> 00:39:54,660
and X contains
polynomial time, then

784
00:39:54,660 --> 00:39:59,750
you could can also solve A
in the same complexity class.

785
00:39:59,750 --> 00:40:02,050
So for example,
if B is in PSPACE,

786
00:40:02,050 --> 00:40:03,880
then we learn that
A is in PSPACE.

787
00:40:03,880 --> 00:40:06,220
Something like that.

788
00:40:06,220 --> 00:40:08,550
Cool.

789
00:40:08,550 --> 00:40:11,814
Any questions at this point?

790
00:40:11,814 --> 00:40:12,715
AUDIENCE: Question.

791
00:40:12,715 --> 00:40:13,381
PROFESSOR: Yeah?

792
00:40:13,381 --> 00:40:15,494
AUDIENCE: You've talked
a lot about thi NP thing.

793
00:40:15,494 --> 00:40:17,952
Why don't you ever talk about
non-deterministic exponential

794
00:40:17,952 --> 00:40:19,989
orobelms or things like that.

795
00:40:19,989 --> 00:40:20,572
PROFESSOR: OK.

796
00:40:20,572 --> 00:40:23,040
Yeah, I didn't define
non-deterministic exponential

797
00:40:23,040 --> 00:40:24,960
problems, but that's
a valid thing.

798
00:40:24,960 --> 00:40:27,480
I think it's usually
written NEXP.

799
00:40:27,480 --> 00:40:31,390
And I believe there
is a class of games

800
00:40:31,390 --> 00:40:32,990
that naturally fits into NEXP.

801
00:40:32,990 --> 00:40:36,380
Its mainly an issue of
which classes commonly arise

802
00:40:36,380 --> 00:40:38,107
in problems that we care about.

803
00:40:38,107 --> 00:40:39,690
This is a pretty
rare one, but I think

804
00:40:39,690 --> 00:40:42,680
there might be one instance
where-- we might touch on this.

805
00:40:42,680 --> 00:40:44,250
Yeah, we definitely can.

806
00:40:44,250 --> 00:40:47,270
It's the same open problem
where EXP equals NEXP.

807
00:40:47,270 --> 00:40:48,687
I mean, it's another
open problem.

808
00:40:48,687 --> 00:40:49,936
I shouldn't say it's the same.

809
00:40:49,936 --> 00:40:51,872
I think you could solve
one without the other.

810
00:40:51,872 --> 00:40:53,580
Again, everyone believes
you can't do it.

811
00:40:53,580 --> 00:40:54,955
If you believe
you can't engineer

812
00:40:54,955 --> 00:40:58,440
luckiness, then of course,
NEXP doesn't equal EXP.

813
00:40:58,440 --> 00:41:03,370
But that would fit
right after EXP.

814
00:41:03,370 --> 00:41:05,730
If you get NEXP, and
then you get EXPSPACE.

815
00:41:05,730 --> 00:41:08,230
According to the things we've
written down and cared about,

816
00:41:08,230 --> 00:41:09,646
that would be the
order of things.

817
00:41:09,646 --> 00:41:12,450
Of course there are
classes in between these,

818
00:41:12,450 --> 00:41:14,290
but these are the ones
that appear normally.

819
00:41:14,290 --> 00:41:14,922
Yeah?

820
00:41:14,922 --> 00:41:17,130
AUDIENCE: Do we know how to
use hardness assumptions,

821
00:41:17,130 --> 00:41:19,080
for example, P not
equal to NP to say

822
00:41:19,080 --> 00:41:21,635
whether there exists problems
that are not in P nor NP

823
00:41:21,635 --> 00:41:23,474
complete?

824
00:41:23,474 --> 00:41:24,140
PROFESSOR: Yeah.

825
00:41:24,140 --> 00:41:27,290
That's another
big open question.

826
00:41:27,290 --> 00:41:29,480
Let's say P does not equal NP.

827
00:41:29,480 --> 00:41:31,400
Are there problems here?

828
00:41:31,400 --> 00:41:34,400
Which is to say strictly in
between being-- so they're

829
00:41:34,400 --> 00:41:37,110
still not in P to the
right of this line,

830
00:41:37,110 --> 00:41:39,450
but they're also easier
than NP-complete problems.

831
00:41:39,450 --> 00:41:41,330
There are a couple
problems that are famously

832
00:41:41,330 --> 00:41:46,880
conjectured to live there, like
factoring integers and graph

833
00:41:46,880 --> 00:41:47,660
isomorphism.

834
00:41:47,660 --> 00:41:52,860
But I'm not aware of any
nice complexity class there.

835
00:41:52,860 --> 00:41:55,910
You can, of course,
say-- you can

836
00:41:55,910 --> 00:41:57,370
talk about a class
of problems that

837
00:41:57,370 --> 00:42:01,170
are as hard as graph
isomorphism in a certain sense,

838
00:42:01,170 --> 00:42:03,960
that if you believe-- if
you have a graph isomorphism

839
00:42:03,960 --> 00:42:05,442
Oracle, what can you do?

840
00:42:05,442 --> 00:42:07,900
So there's a little bit of work
trying to chart that space,

841
00:42:07,900 --> 00:42:11,169
but I'd say in general, it's
been not super successful.

842
00:42:11,169 --> 00:42:12,460
Don't quote me on that, though.

843
00:42:12,460 --> 00:42:15,310
I also don't know the
literature super well there.

844
00:42:15,310 --> 00:42:18,832
So that's a big uncharted
territory, let's say.

845
00:42:18,832 --> 00:42:19,790
Could be a big project.

846
00:42:19,790 --> 00:42:23,080
Probably lots of
open problems there.

847
00:42:23,080 --> 00:42:23,870
Other questions?

848
00:42:23,870 --> 00:42:27,180
I think most people believe
there are things there.

849
00:42:27,180 --> 00:42:28,680
One thing you could
prove is there's

850
00:42:28,680 --> 00:42:31,870
a thing called exponential
time hypothesis, which

851
00:42:31,870 --> 00:42:35,510
would say that [? sat ?] has
no sub-exponential algorithm.

852
00:42:35,510 --> 00:42:37,210
Nothing to the
[? little o of ?] N.

853
00:42:37,210 --> 00:42:39,296
If you believe that,
then it's known

854
00:42:39,296 --> 00:42:40,670
there are some
things in between.

855
00:42:40,670 --> 00:42:42,355
You can pick your
favorite function, like N

856
00:42:42,355 --> 00:42:44,438
to Log [? Log ?] N. That's
bigger than polynomial,

857
00:42:44,438 --> 00:42:46,000
but smaller than exponential.

858
00:42:46,000 --> 00:42:49,267
And there are problems that are
in that class and not [? NP. ?]

859
00:42:49,267 --> 00:42:50,850
So definitely with
ETH, you can do it.

860
00:42:50,850 --> 00:42:51,961
Yeah.

861
00:42:51,961 --> 00:42:53,502
AUDIENCE: So regarding
that question,

862
00:42:53,502 --> 00:42:57,560
I think it has been proven
that if P not equal NP, then

863
00:42:57,560 --> 00:42:58,652
there is stuff in there.

864
00:42:58,652 --> 00:42:59,652
PROFESSOR: Oh, there is.

865
00:42:59,652 --> 00:43:00,500
Yeah.

866
00:43:00,500 --> 00:43:03,240
AUDIENCE: Or you can kind
of do a diagonalization.

867
00:43:03,240 --> 00:43:05,190
PROFESSOR: Other questions?

868
00:43:05,190 --> 00:43:05,690
Yeah?

869
00:43:05,690 --> 00:43:09,180
AUDIENCE: What's the decision
problem for the factoring?

870
00:43:09,180 --> 00:43:11,900
PROFESSOR: Decision
problem for factoring.

871
00:43:11,900 --> 00:43:16,090
I think one version is
I give you a number,

872
00:43:16,090 --> 00:43:18,190
and I give you a
bit position, and I

873
00:43:18,190 --> 00:43:21,280
want to know whether there
is a factor that has a 0 or 1

874
00:43:21,280 --> 00:43:22,537
in that position.

875
00:43:22,537 --> 00:43:24,870
So if you can solve the
problem, then by repeated calls,

876
00:43:24,870 --> 00:43:29,900
you could actually find
a factor that's not 1.

877
00:43:29,900 --> 00:43:32,025
I don't know if there's a
better version than that.

878
00:43:32,025 --> 00:43:34,191
You have to be careful, of
course, if you say, well,

879
00:43:34,191 --> 00:43:35,180
is the number prime?

880
00:43:35,180 --> 00:43:36,830
Then that's in polynomial time.

881
00:43:36,830 --> 00:43:39,080
That was a big result
a bunch of years ago.

882
00:43:39,080 --> 00:43:40,340
So, yeah.

883
00:43:43,670 --> 00:43:46,750
Most of the time, it's easy
to go from your optimization

884
00:43:46,750 --> 00:43:48,580
problem to a decision problem.

885
00:43:48,580 --> 00:43:53,876
But factoring is one
where it's less clear.

886
00:43:53,876 --> 00:43:54,500
More questions?

887
00:43:59,020 --> 00:44:01,350
That was a lot in a
small amount of time.

888
00:44:01,350 --> 00:44:03,600
But that's all you should
need from complexity theory.

889
00:44:03,600 --> 00:44:04,309
Yeah?

890
00:44:04,309 --> 00:44:04,850
AUDIENCE: OK.

891
00:44:04,850 --> 00:44:08,329
I guess I have a question
about the way you defined NP

892
00:44:08,329 --> 00:44:10,036
with the [INAUDIBLE] algorithms?

893
00:44:10,036 --> 00:44:10,660
PROFESSOR: Yup.

894
00:44:10,660 --> 00:44:12,201
AUDIENCE: So the
definition that I've

895
00:44:12,201 --> 00:44:15,542
seen before is in
terms of [INAUDIBLE].

896
00:44:15,542 --> 00:44:16,250
PROFESSOR: Right.

897
00:44:16,250 --> 00:44:19,140
AUDIENCE: And there, it
specifically constrains

898
00:44:19,140 --> 00:44:22,638
every branch in the computation
to run polynomial time,

899
00:44:22,638 --> 00:44:27,136
whereas you can imagine a lucky
algorithm that avoids infinite

900
00:44:27,136 --> 00:44:29,387
looping just because it's lucky.

901
00:44:29,387 --> 00:44:29,970
PROFESSOR: Oh.

902
00:44:29,970 --> 00:44:30,330
OK.

903
00:44:30,330 --> 00:44:30,960
Yeah.

904
00:44:30,960 --> 00:44:33,240
I was a little vague here.

905
00:44:33,240 --> 00:44:35,340
For the definition of NP
, I said polynomial time

906
00:44:35,340 --> 00:44:36,780
in the worst case.

907
00:44:36,780 --> 00:44:39,140
Probably I need to say it's
polynomial time no matter

908
00:44:39,140 --> 00:44:42,470
what branch you take.

909
00:44:42,470 --> 00:44:44,160
Not sure it matters.

910
00:44:44,160 --> 00:44:46,880
Because maybe if you
know your algorithm's

911
00:44:46,880 --> 00:44:50,100
supposed to run in polynomial
time, you could have a timer,

912
00:44:50,100 --> 00:44:53,630
and if it ever exceeds
that time, just return no.

913
00:44:53,630 --> 00:44:56,250
So you might be able
to convert the weaker

914
00:44:56,250 --> 00:44:58,370
notion of polynomial
time to the stronger one.

915
00:44:58,370 --> 00:45:01,310
But it won't matter too much.

916
00:45:01,310 --> 00:45:04,160
I mean, in all the
algorithms we'll think about,

917
00:45:04,160 --> 00:45:06,340
every branch you could
possibly think of even,

918
00:45:06,340 --> 00:45:08,090
the non-lucky ones,
are polynomial time.

919
00:45:08,090 --> 00:45:10,339
So we will stick to that.

920
00:45:10,339 --> 00:45:12,130
We won't spend much
time in general proving

921
00:45:12,130 --> 00:45:13,931
that problems are
in NP or NPSPACE,

922
00:45:13,931 --> 00:45:15,930
only to check that this
is the right class we're

923
00:45:15,930 --> 00:45:17,180
supposed to be working in.

924
00:45:17,180 --> 00:45:19,950
We'll spend most of our time
proving the hardness cases,

925
00:45:19,950 --> 00:45:20,960
the lower bounds.

926
00:45:20,960 --> 00:45:22,014
Yeah?

927
00:45:22,014 --> 00:45:23,966
AUDIENCE: So you
mentioned that if you

928
00:45:23,966 --> 00:45:27,142
use different notions of a
reduction, different limit

929
00:45:27,142 --> 00:45:28,994
space equally on
the competition,

930
00:45:28,994 --> 00:45:31,167
you get different
measures of as hard as.

931
00:45:31,167 --> 00:45:31,793
PROFESSOR: Yes.

932
00:45:31,793 --> 00:45:33,458
AUDIENCE: So as your
classes get bigger,

933
00:45:33,458 --> 00:45:35,739
does it matter if you start
using more polynomial time

934
00:45:35,739 --> 00:45:36,488
in your reduction?

935
00:45:36,488 --> 00:45:38,720
Does it actually change?

936
00:45:38,720 --> 00:45:40,200
PROFESSOR: I'm sure it matters.

937
00:45:40,200 --> 00:45:43,980
But again, it's
beyond the classes

938
00:45:43,980 --> 00:45:46,750
that are usually considered
from an algorithmic standpoint.

939
00:45:46,750 --> 00:45:49,250
Bigger than these classes
don't seem to matter much.

940
00:45:49,250 --> 00:45:51,500
And in these, maybe
once I've seen like,

941
00:45:51,500 --> 00:45:54,990
a polynomial space reduction
to prove X-hardness,

942
00:45:54,990 --> 00:45:56,850
so it's a slightly
weaker notion than if you

943
00:45:56,850 --> 00:46:00,520
do a polynomial time
reduction, but if you

944
00:46:00,520 --> 00:46:04,040
believe PSPACE does not equal
X, but still a separation.

945
00:46:04,040 --> 00:46:06,280
So sometimes, things
like that happen.

946
00:46:06,280 --> 00:46:08,510
I think the most common is
just switching to a space

947
00:46:08,510 --> 00:46:10,832
measure over time measure.

948
00:46:10,832 --> 00:46:13,040
I don't think it will matter
in anything we see here.

949
00:46:13,040 --> 00:46:15,540
But it does arise
in the literature.

950
00:46:15,540 --> 00:46:17,000
Definitely.

951
00:46:17,000 --> 00:46:20,740
I think PSPACE or log space
are the two common ones.

952
00:46:20,740 --> 00:46:24,132
And of course, when you're doing
P-completeness, it's another.

953
00:46:24,132 --> 00:46:25,382
Yeah?

954
00:46:25,382 --> 00:46:27,340
AUDIENCE: You mentioned
setting it [INAUDIBLE],

955
00:46:27,340 --> 00:46:29,850
and I'm curious how
you could do that.

956
00:46:29,850 --> 00:46:35,090
Because for any
instance of the problem,

957
00:46:35,090 --> 00:46:37,950
you can't say that I've
used exponential time.

958
00:46:37,950 --> 00:46:40,707
It could just be that there's
a bigger constant out front.

959
00:46:40,707 --> 00:46:41,290
PROFESSOR: OK.

960
00:46:41,290 --> 00:46:44,100
Yeah, so you need to know
what the polynomial is

961
00:46:44,100 --> 00:46:45,860
for it to have a timer.

962
00:46:45,860 --> 00:46:47,275
That's a small catch.

963
00:46:50,110 --> 00:46:50,610
Yeah.

964
00:46:50,610 --> 00:46:53,780
I don't see an easy
way to avoid that.

965
00:46:53,780 --> 00:46:54,280
Yeah.

966
00:46:54,280 --> 00:46:57,061
There's some few subtle
constructive issues there.

967
00:46:57,061 --> 00:46:58,560
If you don't know
what the bound is,

968
00:46:58,560 --> 00:46:59,927
then things get more annoying.

969
00:46:59,927 --> 00:47:01,760
None of those things
will happen in reality.

970
00:47:01,760 --> 00:47:04,390
So remember, this not
a complexity class.

971
00:47:04,390 --> 00:47:08,090
We're looking at
algorithms here.

972
00:47:08,090 --> 00:47:09,510
This part is actually easy.

973
00:47:09,510 --> 00:47:11,830
It's all about the reductions.

974
00:47:11,830 --> 00:47:14,520
That's where the meat
of this class will be.

975
00:47:14,520 --> 00:47:17,980
And for that, we need
to get NP-hardcore.

976
00:47:17,980 --> 00:47:20,370
AUDIENCE: [LAUGHING].

977
00:47:20,370 --> 00:47:23,600
PROFESSOR: I think all of
you soon will be NP-hardore,

978
00:47:23,600 --> 00:47:27,520
and we'll be able to prove
really hard problems really

979
00:47:27,520 --> 00:47:29,570
hard.

980
00:47:29,570 --> 00:47:32,830
So in the spirit
of NP-hardcoreness,

981
00:47:32,830 --> 00:47:36,250
we're going to take the classic
of hardcore video games, Super

982
00:47:36,250 --> 00:47:37,480
Mario Brothers.

983
00:47:37,480 --> 00:47:41,150
And our first proof will be
that Mario Brothers is NP-hard.

984
00:47:41,150 --> 00:47:43,290
This got lots of
press, like here's

985
00:47:43,290 --> 00:47:45,020
Kotaku saying, "Science
proves old video

986
00:47:45,020 --> 00:47:46,654
games were super hard."

987
00:47:46,654 --> 00:47:49,440
AUDIENCE: [LAUGHING].

988
00:47:49,440 --> 00:47:54,060
PROFESSOR: This is proving
the obvious, I guess.

989
00:47:54,060 --> 00:47:56,890
But anyway.

990
00:47:56,890 --> 00:48:00,720
So let me tell you a little
bit about how this proof goes,

991
00:48:00,720 --> 00:48:01,870
and then we will see it.

992
00:48:18,160 --> 00:48:19,270
All right.

993
00:48:19,270 --> 00:48:24,040
So we need a problem
to reduce from.

994
00:48:24,040 --> 00:48:25,410
The problem is 3SAT.

995
00:48:25,410 --> 00:48:28,074
This is probably the most
common problem to reduce from.

996
00:48:28,074 --> 00:48:29,740
We will spend a bunch
of lectures on it.

997
00:48:29,740 --> 00:48:31,710
It won't be our very
next class, but we

998
00:48:31,710 --> 00:48:32,905
will get to it pretty soon.

999
00:48:32,905 --> 00:48:34,530
This is also known
as 3-Satisfiability.

1000
00:48:37,250 --> 00:48:39,380
If you're ever trying
to prove NP-hardness

1001
00:48:39,380 --> 00:48:42,040
and you don't know where to
start from, the answer is 3SAT.

1002
00:48:42,040 --> 00:48:44,005
Almost always, but not always.

1003
00:48:47,647 --> 00:48:51,976
AUDIENCE: [LAUGHING]

1004
00:48:51,976 --> 00:48:53,419
PROFESSOR: OK.

1005
00:48:53,419 --> 00:48:54,880
Whatever.

1006
00:48:54,880 --> 00:48:56,590
So what's the problem?

1007
00:48:56,590 --> 00:49:00,320
You're given a 3CNF formula.

1008
00:49:00,320 --> 00:49:06,330
This means something
like x5, or I'll

1009
00:49:06,330 --> 00:49:14,180
be nice and write
English, or x3, or not x1.

1010
00:49:17,120 --> 00:49:27,510
And another thing like
that. x7, or not x2, or x5.

1011
00:49:27,510 --> 00:49:28,010
Whatever.

1012
00:49:31,570 --> 00:49:35,590
So some key words
you should know.

1013
00:49:35,590 --> 00:49:36,126
xI's.

1014
00:49:36,126 --> 00:49:37,250
Those are called variables.

1015
00:49:40,500 --> 00:49:42,690
xI or not xI.

1016
00:49:42,690 --> 00:49:46,560
Those are called literals.

1017
00:49:46,560 --> 00:49:47,490
You have two choices.

1018
00:49:47,490 --> 00:49:49,410
You could either have
a positive variable

1019
00:49:49,410 --> 00:49:51,400
or a negative variable.

1020
00:49:51,400 --> 00:49:56,580
Then you always have
three literals per clause.

1021
00:49:56,580 --> 00:49:58,950
These things are called--
each row of this thing

1022
00:49:58,950 --> 00:50:00,375
that I drew is called a clause.

1023
00:50:03,480 --> 00:50:05,600
The whole thing's
called a formula.

1024
00:50:05,600 --> 00:50:09,740
And the question is, can
you make this formula true?

1025
00:50:09,740 --> 00:50:13,020
So that's what you want to know.

1026
00:50:13,020 --> 00:50:19,929
Do there exist xI's such
that the formula is true?

1027
00:50:19,929 --> 00:50:21,095
That's the decision problem.

1028
00:50:25,550 --> 00:50:26,570
And it's NP-complete.

1029
00:50:29,277 --> 00:50:31,360
It is almost the first
problem proved NP-complete.

1030
00:50:37,030 --> 00:50:40,220
It's like the second
problem that's NP-complete.

1031
00:50:40,220 --> 00:50:44,730
The first one was without
this particular style.

1032
00:50:44,730 --> 00:50:46,790
It was just a bunch of
ands and or's and nots

1033
00:50:46,790 --> 00:50:48,760
in any combination.

1034
00:50:48,760 --> 00:50:50,850
But this is also hard,
and it's usually easier

1035
00:50:50,850 --> 00:50:52,600
to start from this situation.

1036
00:50:52,600 --> 00:50:56,110
So what we want to do
is reduce from 3SAT

1037
00:50:56,110 --> 00:50:58,361
to Super Mario Brothers.

1038
00:50:58,361 --> 00:50:58,860
OK.

1039
00:50:58,860 --> 00:51:03,060
So let's do it.

1040
00:51:03,060 --> 00:51:05,465
So I should mention our proof
holds Super Mario Brothers

1041
00:51:05,465 --> 00:51:09,044
1, Lost Levels, and 3.

1042
00:51:09,044 --> 00:51:10,710
Super Mario Brothers
2 is another world.

1043
00:51:10,710 --> 00:51:14,750
Also, Super Mario
Worlds, I think 1 and 2.

1044
00:51:14,750 --> 00:51:18,810
But most the pictures will be
Super Mario Brothers Original.

1045
00:51:18,810 --> 00:51:22,220
So what we're going to
do are build gadgets.

1046
00:51:22,220 --> 00:51:24,450
Gadgets are in this
case little pieces

1047
00:51:24,450 --> 00:51:26,810
of levels that we're
going to join together

1048
00:51:26,810 --> 00:51:29,180
to make the actual reduction.

1049
00:51:29,180 --> 00:51:31,595
So it's usually--
it's not typical

1050
00:51:31,595 --> 00:51:35,190
that you look at the instance of
A, and just think really hard,

1051
00:51:35,190 --> 00:51:39,020
and then just output an
instance of B from nowhere.

1052
00:51:39,020 --> 00:51:42,860
You just say, well, OK, instance
of A has lots of little pieces.

1053
00:51:42,860 --> 00:51:44,640
It's got variables,
and literals,

1054
00:51:44,640 --> 00:51:46,257
and clauses, and a formula.

1055
00:51:46,257 --> 00:51:48,340
I'm just going to take
each of those little pieces

1056
00:51:48,340 --> 00:51:50,505
and convert them into a
little piece in my output,

1057
00:51:50,505 --> 00:51:52,049
and then just string
them altogether

1058
00:51:52,049 --> 00:51:54,465
in a usually fairly obvious
way, though sometimes, there's

1059
00:51:54,465 --> 00:51:55,910
some subtleties there.

1060
00:51:55,910 --> 00:51:58,270
Almost all of our proofs
will follow this structure.

1061
00:51:58,270 --> 00:52:00,020
This is gadget
structure, and this is

1062
00:52:00,020 --> 00:52:01,540
the thing you're here to learn.

1063
00:52:01,540 --> 00:52:02,880
And it's super cool.

1064
00:52:02,880 --> 00:52:05,870
Because once you know
that you want to do 3SAT,

1065
00:52:05,870 --> 00:52:08,330
you're like, OK, I need
variables in closets.

1066
00:52:08,330 --> 00:52:10,570
So here's the variable.

1067
00:52:10,570 --> 00:52:12,450
Got Mario on the top.

1068
00:52:12,450 --> 00:52:17,720
Mario has to decide should
he go left or right?

1069
00:52:17,720 --> 00:52:19,680
I mean, you could
go back, but if you

1070
00:52:19,680 --> 00:52:22,560
want to go through
this gadget, you

1071
00:52:22,560 --> 00:52:24,470
can either fall
left or fall right.

1072
00:52:24,470 --> 00:52:27,170
And all of these heights
are so large that once you

1073
00:52:27,170 --> 00:52:29,420
make that decision, you can't
come back up because you

1074
00:52:29,420 --> 00:52:32,120
have a limited jump height.

1075
00:52:32,120 --> 00:52:32,790
OK.

1076
00:52:32,790 --> 00:52:35,430
Here's the clause gadget.

1077
00:52:35,430 --> 00:52:38,290
So the idea of variables
we're choosing,

1078
00:52:38,290 --> 00:52:40,750
do I set x5 to be true or false?

1079
00:52:40,750 --> 00:52:43,047
Let's say the left branch
corresponds to true,

1080
00:52:43,047 --> 00:52:44,630
the right branch
corresponds to false.

1081
00:52:44,630 --> 00:52:46,296
How that happens,
we'll see in a moment.

1082
00:52:46,296 --> 00:52:48,790
That's about how the
gadgets fit together.

1083
00:52:48,790 --> 00:52:51,390
Clause gadget has two parts.

1084
00:52:51,390 --> 00:52:54,370
On the one hand, you have
these three entry points

1085
00:52:54,370 --> 00:52:58,810
where your goal is to hit
koopas and bounce them around.

1086
00:52:58,810 --> 00:53:02,030
And then the other part is down
here, is a bunch of bricks.

1087
00:53:02,030 --> 00:53:05,200
And at the end of the level,
we're going to set it up

1088
00:53:05,200 --> 00:53:08,820
so Mario has to go
through this part.

1089
00:53:08,820 --> 00:53:11,230
And this will be
traversable if and only

1090
00:53:11,230 --> 00:53:13,300
if these bricks
have been broken.

1091
00:53:13,300 --> 00:53:16,200
So how would you do that?

1092
00:53:16,200 --> 00:53:19,140
This brick-- well, various
things are in the way

1093
00:53:19,140 --> 00:53:24,717
here, so what you need
to do-- interesting.

1094
00:53:24,717 --> 00:53:26,800
But we're going to change
this gadget in a second.

1095
00:53:26,800 --> 00:53:28,216
I already see some
issues with it.

1096
00:53:28,216 --> 00:53:30,270
But this was our original.

1097
00:53:30,270 --> 00:53:32,740
Original proof
didn't get published,

1098
00:53:32,740 --> 00:53:36,340
and we ended up fixing it
before we submitted it.

1099
00:53:36,340 --> 00:53:40,270
So the idea is what we want
Mario to do is come down here,

1100
00:53:40,270 --> 00:53:43,135
hit the koopa, and then
knock the shell out here,

1101
00:53:43,135 --> 00:53:44,760
and it will bounce
and eventually break

1102
00:53:44,760 --> 00:53:45,850
all these bricks.

1103
00:53:45,850 --> 00:53:46,870
Right?

1104
00:53:46,870 --> 00:53:49,560
Well, no, that would be
Super Mario Brothers 3, where

1105
00:53:49,560 --> 00:53:51,230
turtles actually break bricks.

1106
00:53:51,230 --> 00:53:53,090
In Super Mario
Brothers 1, they don't.

1107
00:53:53,090 --> 00:53:57,380
So we will use a
different gadget

1108
00:53:57,380 --> 00:54:00,930
with fire bars and
question blocks

1109
00:54:00,930 --> 00:54:04,010
with invincibility
stars in them.

1110
00:54:04,010 --> 00:54:04,510
OK.

1111
00:54:04,510 --> 00:54:06,210
So same idea.

1112
00:54:06,210 --> 00:54:08,800
There are three
entrances down here.

1113
00:54:08,800 --> 00:54:11,030
If you hit any one of
them, then the star

1114
00:54:11,030 --> 00:54:13,170
will just float
around here forever.

1115
00:54:13,170 --> 00:54:13,900
We tested it.

1116
00:54:13,900 --> 00:54:16,550
It goes there for as long
as the level can last.

1117
00:54:16,550 --> 00:54:20,480
Then later, if you come
here, lots of testing

1118
00:54:20,480 --> 00:54:23,040
involved, of course.

1119
00:54:23,040 --> 00:54:25,697
Later if you come into here,
and you can get the star,

1120
00:54:25,697 --> 00:54:28,030
you have just enough time to
run through all these fire.

1121
00:54:28,030 --> 00:54:30,630
Bars if you don't, you will die.

1122
00:54:30,630 --> 00:54:31,130
OK?

1123
00:54:31,130 --> 00:54:34,110
So that's the clause gadget.

1124
00:54:34,110 --> 00:54:37,710
So if you visit in at least
one of these three places--

1125
00:54:37,710 --> 00:54:39,480
you can visit all
of them, it doesn't

1126
00:54:39,480 --> 00:54:42,160
help to have three stars
versus one in this case,

1127
00:54:42,160 --> 00:54:45,830
because they don't
stack or anything-- then

1128
00:54:45,830 --> 00:54:49,156
and only then can you
go through the top part.

1129
00:54:49,156 --> 00:54:50,780
This is what we might
call a traversal,

1130
00:54:50,780 --> 00:54:55,079
and this is-- you could call
it setting the gadget to True.

1131
00:54:55,079 --> 00:54:56,370
How does this all fit together?

1132
00:54:56,370 --> 00:54:58,520
This is sort of
the bigger issue.

1133
00:54:58,520 --> 00:55:02,780
So we're going to take
this three set instance.

1134
00:55:02,780 --> 00:55:05,780
It's got variables and clauses.

1135
00:55:05,780 --> 00:55:09,040
And let's ignore the
negations for now.

1136
00:55:09,040 --> 00:55:10,525
Am I going to ignore them?

1137
00:55:10,525 --> 00:55:11,900
No, I'm not going
to ignore them.

1138
00:55:11,900 --> 00:55:15,370
But on the one hand,
we have variables.

1139
00:55:15,370 --> 00:55:16,830
On the other hand,
we have clauses.

1140
00:55:16,830 --> 00:55:19,080
And we're going to
connect each variable

1141
00:55:19,080 --> 00:55:21,470
to the clause that contains it.

1142
00:55:21,470 --> 00:55:24,640
So this is an actual set
of four clauses here,

1143
00:55:24,640 --> 00:55:26,220
and you can trace them all.

1144
00:55:26,220 --> 00:55:29,640
So the claim is that
x in the positive form

1145
00:55:29,640 --> 00:55:31,940
appears in the first clause
and the second clause.

1146
00:55:31,940 --> 00:55:33,960
You can see there's an
x here and an x here.

1147
00:55:33,960 --> 00:55:35,860
It appears in the
negative one-- this is not

1148
00:55:35,860 --> 00:55:43,640
x-- in clause three and four,
because here's not x and not x.

1149
00:55:43,640 --> 00:55:44,339
And so on.

1150
00:55:44,339 --> 00:55:46,630
So that's what all these
connections in the middle are.

1151
00:55:46,630 --> 00:55:48,570
In general, it's kind
of a bipartite graph.

1152
00:55:48,570 --> 00:55:50,640
You've got variables on
the one side, clauses

1153
00:55:50,640 --> 00:55:52,740
on the other side,
and we happened

1154
00:55:52,740 --> 00:55:56,110
to have coalesced
things in these groups.

1155
00:55:56,110 --> 00:55:59,210
What these edges are now
going to be converted into

1156
00:55:59,210 --> 00:56:01,470
are paths for Mario to follow.

1157
00:56:01,470 --> 00:56:04,070
So this is the variable gadget.

1158
00:56:04,070 --> 00:56:05,010
It's this thing.

1159
00:56:05,010 --> 00:56:06,900
We're just going to
plug that in here.

1160
00:56:06,900 --> 00:56:09,090
So the idea is you
enter from here,

1161
00:56:09,090 --> 00:56:13,630
and then you have two
ways that you can go,

1162
00:56:13,630 --> 00:56:16,470
either the true way
or the false way.

1163
00:56:16,470 --> 00:56:18,320
If you set the
variable to True, you

1164
00:56:18,320 --> 00:56:21,760
can then go and visit
the corresponding clauses

1165
00:56:21,760 --> 00:56:26,240
that contain it and
get one of the stars.

1166
00:56:26,240 --> 00:56:26,810
OK.

1167
00:56:26,810 --> 00:56:28,985
Now, for each
variable, you only get

1168
00:56:28,985 --> 00:56:30,360
to make one of
those choices then

1169
00:56:30,360 --> 00:56:34,830
you satisfy all the causes
that contain that literal.

1170
00:56:34,830 --> 00:56:37,470
And then when you're done, you
can walk to the next variable.

1171
00:56:40,270 --> 00:56:43,300
So there's actually two
entrances to the variable.

1172
00:56:43,300 --> 00:56:44,620
I guess that kind of matters.

1173
00:56:44,620 --> 00:56:47,310
What we want in the variable--
so you came from the True

1174
00:56:47,310 --> 00:56:49,430
setting, or you came
from the False setting,

1175
00:56:49,430 --> 00:56:51,460
you don't want to be
able to run and jump over

1176
00:56:51,460 --> 00:56:52,890
to the other side
and the satisfy

1177
00:56:52,890 --> 00:56:54,880
the previous variable
both true and false.

1178
00:56:54,880 --> 00:56:56,950
You only get to make one choice.

1179
00:56:56,950 --> 00:56:59,140
Lots of things check here.

1180
00:56:59,140 --> 00:57:01,250
Then in the end, at the
very end after you've

1181
00:57:01,250 --> 00:57:03,650
set the last variable,
you have to traverse

1182
00:57:03,650 --> 00:57:05,829
all of these clauses
through the fire bars.

1183
00:57:05,829 --> 00:57:07,620
And that's going to be
possible if and only

1184
00:57:07,620 --> 00:57:10,842
if every one of the
causes has a star in it.

1185
00:57:10,842 --> 00:57:13,850
In other words, the variables
satisfy all the clauses.

1186
00:57:13,850 --> 00:57:15,570
In other words, the
formula is true,

1187
00:57:15,570 --> 00:57:18,520
because the clauses are
combined with an and.

1188
00:57:18,520 --> 00:57:19,090
OK?

1189
00:57:19,090 --> 00:57:21,110
That is in a nutshell the proof.

1190
00:57:21,110 --> 00:57:22,868
Once you've made
this construction

1191
00:57:22,868 --> 00:57:31,850
that the solution to 3SAT is
equal to the solution to Mario

1192
00:57:31,850 --> 00:57:34,630
in general, you want to
prove on the one hand

1193
00:57:34,630 --> 00:57:37,410
if the answer is yes
to 3SAT, if there's

1194
00:57:37,410 --> 00:57:39,550
a valid setting
for the variables,

1195
00:57:39,550 --> 00:57:42,130
then there is a solution
to this Mario instance.

1196
00:57:42,130 --> 00:57:43,820
You can actually
solve the level.

1197
00:57:43,820 --> 00:57:45,860
The decision question
here is, can I make it

1198
00:57:45,860 --> 00:57:46,859
to the end of the level?

1199
00:57:46,859 --> 00:57:48,950
There's a flag over there.

1200
00:57:48,950 --> 00:57:52,820
And conversely, if there is an
actual solution to this puzzle,

1201
00:57:52,820 --> 00:57:54,850
you want to show that
you can convert it

1202
00:57:54,850 --> 00:57:58,180
into a valid setting for 3SAT
that satisfies the formula.

1203
00:57:58,180 --> 00:57:59,300
You need to check both.

1204
00:57:59,300 --> 00:58:02,930
That gives you
the equality here.

1205
00:58:02,930 --> 00:58:04,192
Question?

1206
00:58:04,192 --> 00:58:07,590
AUDIENCE: Don't you need
this graph to be planar?

1207
00:58:07,590 --> 00:58:08,690
PROFESSOR: Good question.

1208
00:58:08,690 --> 00:58:11,730
This graph is not planar, and
so there are these crossings.

1209
00:58:11,730 --> 00:58:15,060
So there's one more gadget,
the crossover gadget.

1210
00:58:15,060 --> 00:58:17,835
And this is on the poster,
so if you were analyzing it.

1211
00:58:17,835 --> 00:58:19,335
There are many ways
to do crossover,

1212
00:58:19,335 --> 00:58:21,780
and this one is kind of
overkill unless I tell you

1213
00:58:21,780 --> 00:58:25,410
that Super Mario Brothers
has tons of hacks and cheats

1214
00:58:25,410 --> 00:58:27,390
that you can play,
and run through walls,

1215
00:58:27,390 --> 00:58:28,100
and crazy things.

1216
00:58:28,100 --> 00:58:30,620
But never mind that.

1217
00:58:30,620 --> 00:58:33,160
The idea here is
you are a big Mario.

1218
00:58:33,160 --> 00:58:35,276
At the beginning of a
level, there's a mushroom.

1219
00:58:35,276 --> 00:58:36,400
And you better not lose it.

1220
00:58:36,400 --> 00:58:38,060
Otherwise, you're in trouble.

1221
00:58:38,060 --> 00:58:40,900
So on the one hand, I can
go from left to right.

1222
00:58:40,900 --> 00:58:42,580
It's a directional crossover.

1223
00:58:42,580 --> 00:58:46,310
Or I can go from-- this
is the bottom to the top.

1224
00:58:46,310 --> 00:58:47,910
But I can't go from
bottom to right.

1225
00:58:47,910 --> 00:58:49,270
I can't go from bottom to left.

1226
00:58:49,270 --> 00:58:51,380
All these sorts of things.

1227
00:58:51,380 --> 00:58:52,630
Why?

1228
00:58:52,630 --> 00:58:53,130
OK.

1229
00:58:53,130 --> 00:58:55,460
Let's do the
positive case first.

1230
00:58:55,460 --> 00:58:56,490
Say I'm from the bottom.

1231
00:58:56,490 --> 00:58:57,140
I fall here.

1232
00:58:57,140 --> 00:58:58,130
Can't go back.

1233
00:58:58,130 --> 00:58:59,630
I can jump.

1234
00:58:59,630 --> 00:59:02,090
If I'm big Mario, I can break
through a couple bricks,

1235
00:59:02,090 --> 00:59:04,020
and then I can escape.

1236
00:59:04,020 --> 00:59:04,770
OK?

1237
00:59:04,770 --> 00:59:08,882
But I could run under here.

1238
00:59:08,882 --> 00:59:11,340
For example, if you're good,
you can crouch slide, and then

1239
00:59:11,340 --> 00:59:12,548
jump, jump, jump, jump, jump.

1240
00:59:12,548 --> 00:59:13,590
You get to here.

1241
00:59:13,590 --> 00:59:15,520
But you cannot get through this.

1242
00:59:15,520 --> 00:59:17,750
Or maybe I need to
add one more wiggle.

1243
00:59:17,750 --> 00:59:19,310
A little easier
to see over here.

1244
00:59:19,310 --> 00:59:21,580
Maybe I can get
here and move over.

1245
00:59:21,580 --> 00:59:23,580
But if you're in
this position, you

1246
00:59:23,580 --> 00:59:27,300
have no momentum you
can gain, and so you

1247
00:59:27,300 --> 00:59:29,180
can't crouch slide into there.

1248
00:59:29,180 --> 00:59:33,510
So if you're here coming from
the bottom, you can't get out.

1249
00:59:33,510 --> 00:59:37,960
Alternatively, if you
come from the left--

1250
00:59:37,960 --> 00:59:39,960
it's so tempting
to kill the goomba.

1251
00:59:39,960 --> 00:59:42,430
But instead of
killing him, you take

1252
00:59:42,430 --> 00:59:44,660
damage, become small
Mario, then you

1253
00:59:44,660 --> 00:59:46,445
can traverse through
here, because you

1254
00:59:46,445 --> 00:59:47,570
don't need to crouch slide.

1255
00:59:47,570 --> 00:59:48,630
You just jump.

1256
00:59:48,630 --> 00:59:51,580
And there's another mushroom
for you to restore big Mario

1257
00:59:51,580 --> 00:59:53,446
and restore the invariant.

1258
00:59:53,446 --> 00:59:55,320
And you better take it
because otherwise, you

1259
00:59:55,320 --> 00:59:57,910
can't get out through here.

1260
00:59:57,910 --> 01:00:02,780
So you're almost forced to go
left to right or bottom to top.

1261
01:00:02,780 --> 01:00:04,880
Now if you traverse
both of these gadgets

1262
01:00:04,880 --> 01:00:07,900
in both directions,
then all bets are off.

1263
01:00:07,900 --> 01:00:09,950
Then you can go from
anywhere to anywhere.

1264
01:00:09,950 --> 01:00:11,420
That's OK.

1265
01:00:11,420 --> 01:00:15,480
Because what we're
worried about in

1266
01:00:15,480 --> 01:00:19,934
this reduction is whether
you can reach certain things.

1267
01:00:19,934 --> 01:00:22,475
If you can reach something, I
don't care whether you reach it

1268
01:00:22,475 --> 01:00:24,307
now or later.

1269
01:00:24,307 --> 01:00:26,140
It's just you don't
want to be able to reach

1270
01:00:26,140 --> 01:00:26,940
unreachable things.

1271
01:00:26,940 --> 01:00:28,590
When you set the
variable to True,

1272
01:00:28,590 --> 01:00:32,070
I don't want to be able to
visit this false vertex ever.

1273
01:00:32,070 --> 01:00:34,670
And if you check
all the crossovers,

1274
01:00:34,670 --> 01:00:38,500
it's enough to build this kind
of thing, which either you

1275
01:00:38,500 --> 01:00:41,250
traverse left to right,
or bottom to top,

1276
01:00:41,250 --> 01:00:44,010
or you can reach both
the left and the bottom,

1277
01:00:44,010 --> 01:00:46,150
and then you can reach anything.

1278
01:00:46,150 --> 01:00:47,822
And you never have
to go right to left.

1279
01:00:47,822 --> 01:00:49,280
You never have to
go top to bottom.

1280
01:00:49,280 --> 01:00:50,988
Because we always know
the order in which

1281
01:00:50,988 --> 01:00:52,480
we're traversing
things and so on.

1282
01:00:52,480 --> 01:00:52,980
OK.

1283
01:00:52,980 --> 01:00:54,690
I think I've waved
my hands enough.

1284
01:00:54,690 --> 01:00:57,252
There are details to check,
but if you're interested,

1285
01:00:57,252 --> 01:00:59,460
you can wait 'til this part
of the class, where we'll

1286
01:00:59,460 --> 01:01:06,600
cover the Legend of Zelda,
Pokemon, Metroid, and I'm

1287
01:01:06,600 --> 01:01:07,820
missing one.

1288
01:01:07,820 --> 01:01:09,300
Donkey Kong Country.

1289
01:01:09,300 --> 01:01:11,340
Donkey Kong Country
is PSPACE-complete.

1290
01:01:11,340 --> 01:01:12,710
That's a hard proof.

1291
01:01:12,710 --> 01:01:14,950
No pun intended.

1292
01:01:14,950 --> 01:01:17,220
So that was Super
Mario Brothers.

1293
01:01:17,220 --> 01:01:18,840
Any more questions?

1294
01:01:18,840 --> 01:01:20,320
You asked the right one.

1295
01:01:20,320 --> 01:01:22,332
I would have gone
to it otherwise.

1296
01:01:22,332 --> 01:01:23,550
Yes?

1297
01:01:23,550 --> 01:01:23,876
AUDIENCE: Are you
sure we'll never have

1298
01:01:23,876 --> 01:01:25,290
to go say, left to right twice?

1299
01:01:29,800 --> 01:01:30,630
PROFESSOR: Yes.

1300
01:01:30,630 --> 01:01:32,280
That's a good question.

1301
01:01:32,280 --> 01:01:36,430
In this gadget, we are not
able to go left to right twice,

1302
01:01:36,430 --> 01:01:39,130
but that's OK.

1303
01:01:39,130 --> 01:01:43,610
What's not really drawn
here but should be is

1304
01:01:43,610 --> 01:01:46,304
we're really taking an
Euler tour of this star,

1305
01:01:46,304 --> 01:01:48,220
so we're going to go
sort of on the left path.

1306
01:01:48,220 --> 01:01:51,006
There's actually two
paths down here maybe.

1307
01:01:51,006 --> 01:01:52,380
We're going to go
down here, then

1308
01:01:52,380 --> 01:01:54,550
we'll come back the other way.

1309
01:01:54,550 --> 01:01:56,780
Here, there are
actual crossovers.

1310
01:01:56,780 --> 01:01:59,360
When we come back, there are
different crossover gadgets.

1311
01:01:59,360 --> 01:02:01,680
Or you could say there's two
crossover gadgets for each

1312
01:02:01,680 --> 01:02:04,400
of these, one for going one
direction, one for coming back.

1313
01:02:07,090 --> 01:02:08,930
Yeah.

1314
01:02:08,930 --> 01:02:11,880
Four crossovers for
each intersection,

1315
01:02:11,880 --> 01:02:14,330
for both directions
and both guys.

1316
01:02:14,330 --> 01:02:16,394
AUDIENCE: I'm mostly
willing to believe you,

1317
01:02:16,394 --> 01:02:18,810
but I just have this nagging
doubt that you can't actually

1318
01:02:18,810 --> 01:02:21,210
arrange all these things
and make them fit together.

1319
01:02:21,210 --> 01:02:21,793
PROFESSOR: OK.

1320
01:02:21,793 --> 01:02:25,170
So there is a top level question
which is, in general, it's

1321
01:02:25,170 --> 01:02:27,080
the gadget assembly problem.

1322
01:02:27,080 --> 01:02:29,800
If I have all these gadgets, can
I actually put them together?

1323
01:02:29,800 --> 01:02:33,300
And it's important,
the output instance

1324
01:02:33,300 --> 01:02:35,570
should have polynomial size.

1325
01:02:35,570 --> 01:02:37,820
I probably should
mention that here.

1326
01:02:37,820 --> 01:02:39,880
It's important.

1327
01:02:39,880 --> 01:02:44,330
Of polynomials.

1328
01:02:44,330 --> 01:02:46,745
Oh, that's polynomial
time algorithm.

1329
01:02:46,745 --> 01:02:47,910
Good, good, good.

1330
01:02:47,910 --> 01:02:48,410
Yes.

1331
01:02:48,410 --> 01:02:51,402
So this is in parentheses.

1332
01:02:51,402 --> 01:02:53,110
Because it's a polynomial
time algorithm,

1333
01:02:53,110 --> 01:02:55,100
you will generate a
polynomial size output,

1334
01:02:55,100 --> 01:02:57,950
because our outputs have to
be represented explicitly

1335
01:02:57,950 --> 01:03:00,020
for reduction.

1336
01:03:00,020 --> 01:03:03,850
So the main issue
is, can you draw this

1337
01:03:03,850 --> 01:03:06,119
in a grid of polynomial size?

1338
01:03:06,119 --> 01:03:07,660
And the short answer
to your question

1339
01:03:07,660 --> 01:03:11,250
is, use standard graph
drawing algorithms.

1340
01:03:11,250 --> 01:03:16,570
If I give you a planar graph,
I can draw it with n vertices.

1341
01:03:16,570 --> 01:03:20,697
I can draw it in a grid
that order n by order n.

1342
01:03:20,697 --> 01:03:22,030
I forget what the best bound is.

1343
01:03:22,030 --> 01:03:23,220
Maybe 6n by 6n.

1344
01:03:23,220 --> 01:03:24,360
Doesn't matter here.

1345
01:03:24,360 --> 01:03:25,770
Now this graph is not planar.

1346
01:03:25,770 --> 01:03:29,227
But if you just add a vertex
for every intersection,

1347
01:03:29,227 --> 01:03:31,060
and there's at most n
squared intersections,

1348
01:03:31,060 --> 01:03:32,830
then I will have a planar graph.

1349
01:03:32,830 --> 01:03:34,140
Then I apply that algorithm.

1350
01:03:34,140 --> 01:03:35,590
It draws everything into a grid.

1351
01:03:35,590 --> 01:03:38,370
I explode that grid
by a factor of 100,

1352
01:03:38,370 --> 01:03:41,480
whatever the largest size of
this gadget is, plunk them in,

1353
01:03:41,480 --> 01:03:43,260
and then I route the tunnels.

1354
01:03:43,260 --> 01:03:45,830
So the only thing I
haven't really filled in

1355
01:03:45,830 --> 01:03:48,380
is how do you route the tunnels
to make them traversable?

1356
01:03:48,380 --> 01:03:50,046
Because if you go up,
you've got to have

1357
01:03:50,046 --> 01:03:51,380
enough stairs along the way.

1358
01:03:51,380 --> 01:03:54,042
But it's an exercise
for the reader.

1359
01:03:54,042 --> 01:03:55,500
There are definitely
details there.

1360
01:03:55,500 --> 01:03:57,580
And in some cases,
they are subtle.

1361
01:03:57,580 --> 01:04:00,140
I'll tell you the most
annoying issue that

1362
01:04:00,140 --> 01:04:02,770
can happen is a parity issue.

1363
01:04:02,770 --> 01:04:04,290
Sometimes, these
gadgets-- I mean,

1364
01:04:04,290 --> 01:04:06,540
you could make them slightly
wider or slightly taller.

1365
01:04:06,540 --> 01:04:07,370
It doesn't matter.

1366
01:04:07,370 --> 01:04:09,990
Sometimes they have to
be even size or odd size.

1367
01:04:09,990 --> 01:04:11,960
And then things don't
always fit up well.

1368
01:04:11,960 --> 01:04:14,900
And that's a pain to do.

1369
01:04:14,900 --> 01:04:19,140
And I had a proof last
month, where I had,

1370
01:04:19,140 --> 01:04:21,709
I think, three separate
parity issues in a row.

1371
01:04:21,709 --> 01:04:23,750
I fixed one, and it's
like, yes, I got the proof.

1372
01:04:23,750 --> 01:04:26,154
And it was like, uh-oh,
there's another parity problem.

1373
01:04:26,154 --> 01:04:27,070
Then I fixed that one.

1374
01:04:27,070 --> 01:04:29,070
And then, uh-oh, there's
another parity problem.

1375
01:04:29,070 --> 01:04:31,930
And finally, the proof
is hopefully correct.

1376
01:04:31,930 --> 01:04:33,950
And we might go through
that as an example.

1377
01:04:33,950 --> 01:04:35,408
So there are
definitely issues that

1378
01:04:35,408 --> 01:04:38,470
can come up in gadget
assembly, but this one

1379
01:04:38,470 --> 01:04:40,163
I'm not worried
about, let's say.

1380
01:04:40,163 --> 01:04:40,982
Yeah?

1381
01:04:40,982 --> 01:04:42,940
AUDIENCE: Did the original
Super Mario Brothers

1382
01:04:42,940 --> 01:04:43,790
allow you to go left?

1383
01:04:43,790 --> 01:04:44,360
PROFESSOR: No.

1384
01:04:44,360 --> 01:04:45,901
In the original
Super Mario Brothers,

1385
01:04:45,901 --> 01:04:47,610
you cannot scroll
the screen left.

1386
01:04:47,610 --> 01:04:48,790
Mario can go left.

1387
01:04:48,790 --> 01:04:52,340
So this is all one screen.

1388
01:04:52,340 --> 01:04:55,690
You always have to generalize
something in your problem.

1389
01:04:55,690 --> 01:05:00,890
And if you say the size of
your screen, it's 320 by 240,

1390
01:05:00,890 --> 01:05:03,160
or whatever in the
original is constant,

1391
01:05:03,160 --> 01:05:05,070
then you can solve
Mario in polynomial time

1392
01:05:05,070 --> 01:05:06,100
by dynamic programming.

1393
01:05:06,100 --> 01:05:08,970
So that's not as interesting.

1394
01:05:08,970 --> 01:05:09,680
Mario 1.

1395
01:05:09,680 --> 01:05:12,460
Of course, any other
Mario, you can go left,

1396
01:05:12,460 --> 01:05:16,300
except sometimes it forgets
the status of your monsters.

1397
01:05:19,151 --> 01:05:21,650
Again, if you have that, you
can solve it in polynomial time

1398
01:05:21,650 --> 01:05:23,320
by dynamic programming.

1399
01:05:23,320 --> 01:05:25,210
So we're in the
sort of, we'll say,

1400
01:05:25,210 --> 01:05:30,140
as intended model, which is
you can have a big level.

1401
01:05:30,140 --> 01:05:31,630
4K is already happening.

1402
01:05:31,630 --> 01:05:33,850
Imagine the future, you
have a giant screen,

1403
01:05:33,850 --> 01:05:35,400
and you play a giant level.

1404
01:05:35,400 --> 01:05:39,600
AUDIENCE: [LAUGHING]

1405
01:05:39,600 --> 01:05:41,310
PROFESSOR: Other questions?

1406
01:05:41,310 --> 01:05:46,070
Now, one question is is Mario
Brothers an NP conjecture?

1407
01:05:46,070 --> 01:05:49,112
No, I think by now we
might have a proof that

1408
01:05:49,112 --> 01:05:50,607
is PSPACE complete.

1409
01:05:50,607 --> 01:05:52,690
But that's not published
yet, or even written yet.

1410
01:05:52,690 --> 01:05:57,660
So it's certainly not
guaranteed, but we think so.

1411
01:05:57,660 --> 01:05:59,290
OK.

1412
01:05:59,290 --> 01:06:04,440
Last proof is Rush Hour.

1413
01:06:04,440 --> 01:06:06,440
Before I get to Rush Hour,
I'm going to tell you

1414
01:06:06,440 --> 01:06:11,110
about another source problem.

1415
01:06:11,110 --> 01:06:14,600
So 3SAT is the
most common problem

1416
01:06:14,600 --> 01:06:19,590
for-- you might call
them short puzzles.

1417
01:06:19,590 --> 01:06:21,279
Mario Brothers is
maybe a short puzzle.

1418
01:06:21,279 --> 01:06:23,070
If you have a time
limit in Mario Brothers,

1419
01:06:23,070 --> 01:06:25,236
then you're guaranteed
you're going to make at most,

1420
01:06:25,236 --> 01:06:28,040
let's say, n moves, and
then the game is over.

1421
01:06:28,040 --> 01:06:30,380
You either dire or you finish.

1422
01:06:30,380 --> 01:06:33,640
And 3-Satisfiability is a
good representation of that.

1423
01:06:33,640 --> 01:06:38,500
For longer games, another
model called constraint logic

1424
01:06:38,500 --> 01:06:40,670
or constraint graphs is useful.

1425
01:06:40,670 --> 01:06:43,080
So let me tell you this problem.

1426
01:06:43,080 --> 01:06:44,700
It's in some sense
simpler than 3SATs.

1427
01:06:44,700 --> 01:06:47,274
On a graph, you have red
edges and blue edges.

1428
01:06:47,274 --> 01:06:48,690
Notice the blue
edges are thicker.

1429
01:06:48,690 --> 01:06:52,030
That means they're twice
as heavy, so that you

1430
01:06:52,030 --> 01:06:54,390
think of this as your machine.

1431
01:06:54,390 --> 01:06:56,930
Now a state of the
machine is going

1432
01:06:56,930 --> 01:06:59,130
to be an orientation
of the graph.

1433
01:06:59,130 --> 01:07:00,920
So every edge is just
going to be oriented

1434
01:07:00,920 --> 01:07:02,500
one way or the other.

1435
01:07:02,500 --> 01:07:04,710
And the constraint--
in general, this

1436
01:07:04,710 --> 01:07:06,470
is called a constrained graph.

1437
01:07:06,470 --> 01:07:08,680
And the constraint
you have to satisfy

1438
01:07:08,680 --> 01:07:11,780
is that at every vertex, you
have at least two units of flow

1439
01:07:11,780 --> 01:07:13,147
pointed into the vertex.

1440
01:07:13,147 --> 01:07:15,480
So here there's actually three
units of flow pointed in.

1441
01:07:15,480 --> 01:07:17,890
There's the red single unit
and the blue double unit.

1442
01:07:17,890 --> 01:07:20,510
Blue's always 2,
red is always 1.

1443
01:07:20,510 --> 01:07:24,199
So if you get the Kindle
edition of this book,

1444
01:07:24,199 --> 01:07:25,990
don't read it on a
black and white display.

1445
01:07:28,700 --> 01:07:30,780
Or the PDF, whatever.

1446
01:07:30,780 --> 01:07:33,950
So what you're allowed
to do in this game,

1447
01:07:33,950 --> 01:07:36,160
the move you're allowed
to do, is reverse an edge.

1448
01:07:36,160 --> 01:07:38,120
As long as you always
satisfy this invariant

1449
01:07:38,120 --> 01:07:40,480
that at least two units
are in, then you're OK.

1450
01:07:40,480 --> 01:07:43,274
So I think here, we're going
to reverse this one first.

1451
01:07:43,274 --> 01:07:45,190
So now we have three
units of flow pointed in.

1452
01:07:45,190 --> 01:07:47,398
You have to check that the
other vertice's satisfied,

1453
01:07:47,398 --> 01:07:48,960
but this one's certainly OK.

1454
01:07:48,960 --> 01:07:51,210
Now because there
are two red units,

1455
01:07:51,210 --> 01:07:53,510
we can reverse the blue one.

1456
01:07:53,510 --> 01:07:57,580
And we cannot reverse
the red ones right now,

1457
01:07:57,580 --> 01:08:00,220
because that would leave only
one unit of flow inwards.

1458
01:08:00,220 --> 01:08:03,110
There's always two.

1459
01:08:03,110 --> 01:08:05,950
So in fact, this vertex that
I've drawn is in some sense

1460
01:08:05,950 --> 01:08:07,455
an AND gate.

1461
01:08:07,455 --> 01:08:09,510
We call it an AND
vertex, because it's not

1462
01:08:09,510 --> 01:08:11,540
a regular gate.

1463
01:08:11,540 --> 01:08:15,440
Over here, we're going to
think of-- it's a little bit

1464
01:08:15,440 --> 01:08:15,940
asymmetric.

1465
01:08:15,940 --> 01:08:18,273
We're going to think of these
as the inputs to the gate,

1466
01:08:18,273 --> 01:08:20,620
and this as the
output of the gate.

1467
01:08:20,620 --> 01:08:23,060
And if the inputs are
pointing out, that's a false.

1468
01:08:23,060 --> 01:08:25,069
If they're pointing
in, that's a true.

1469
01:08:25,069 --> 01:08:27,465
And the output is reverse,
so if it's pointing in,

1470
01:08:27,465 --> 01:08:28,090
that's a false.

1471
01:08:28,090 --> 01:08:30,370
If it's pointing
out, it's a true.

1472
01:08:30,370 --> 01:08:32,729
So here's one
state false, false.

1473
01:08:32,729 --> 01:08:36,060
And so the AND of false
and false is false.

1474
01:08:36,060 --> 01:08:38,580
Here's another state where
both inputs are true,

1475
01:08:38,580 --> 01:08:40,521
and then the output can be true.

1476
01:08:40,521 --> 01:08:41,770
It doesn't have to be, though.

1477
01:08:41,770 --> 01:08:45,149
So in this example, let's
say we reverse this edge.

1478
01:08:45,149 --> 01:08:47,290
So now, we have false and true.

1479
01:08:47,290 --> 01:08:50,550
Still, we can't reverse this
because false and true is

1480
01:08:50,550 --> 01:08:52,979
false, and because
there would only

1481
01:08:52,979 --> 01:08:55,680
be one unit of incoming flow
before we can reverse this.

1482
01:08:55,680 --> 01:08:59,990
If I could reverse it back, I
could reverse the other one.

1483
01:08:59,990 --> 01:09:03,550
Only once I reverse
both of the inputs am

1484
01:09:03,550 --> 01:09:05,040
I allowed to reverse the output.

1485
01:09:05,040 --> 01:09:06,069
But I don't have.

1486
01:09:06,069 --> 01:09:08,729
I could just let it sit there.

1487
01:09:08,729 --> 01:09:10,380
It's not a gate in
the sense that it

1488
01:09:10,380 --> 01:09:12,590
doesn't compute the answer.

1489
01:09:12,590 --> 01:09:16,340
But what you know is that if
you have an output of true,

1490
01:09:16,340 --> 01:09:18,160
you know that the
inputs must be true.

1491
01:09:18,160 --> 01:09:21,740
So it's kind of an AND.

1492
01:09:21,740 --> 01:09:24,340
We call it a
constraint logic AND.

1493
01:09:24,340 --> 01:09:26,680
Now here, this I claim is an OR.

1494
01:09:26,680 --> 01:09:29,410
Now if you look at this in a
graph, it's totally symmetric.

1495
01:09:29,410 --> 01:09:30,609
It's just three blue edges.

1496
01:09:30,609 --> 01:09:32,817
But if you think of these
two as inputs and these two

1497
01:09:32,817 --> 01:09:35,819
as outputs, it's an OR.

1498
01:09:35,819 --> 01:09:39,359
And so what's the point?

1499
01:09:39,359 --> 01:09:42,880
Well, if I reverse any of the
edges, the incoming edges,

1500
01:09:42,880 --> 01:09:44,660
the input edges I
should say, then

1501
01:09:44,660 --> 01:09:46,420
I can reverse the bottom edge.

1502
01:09:46,420 --> 01:09:48,310
I don't have to.

1503
01:09:48,310 --> 01:09:51,420
And I could also do both true.

1504
01:09:51,420 --> 01:09:55,298
This could still
be true, and so on.

1505
01:09:55,298 --> 01:09:56,838
AUDIENCE: So if
it's symmetric, how

1506
01:09:56,838 --> 01:09:58,716
do you constrain some of
them to be inputs and others

1507
01:09:58,716 --> 01:09:59,460
to be outputs?

1508
01:09:59,460 --> 01:10:01,293
PROFESSOR: The inputs
and output distinction

1509
01:10:01,293 --> 01:10:03,610
is only in your head.

1510
01:10:03,610 --> 01:10:05,930
The way that I
used it is I said,

1511
01:10:05,930 --> 01:10:08,890
an input is true if
it's pointing in,

1512
01:10:08,890 --> 01:10:12,850
an output is true if
it's pointing out.

1513
01:10:12,850 --> 01:10:14,760
So that's asymmetric,
and it's just

1514
01:10:14,760 --> 01:10:17,160
a way of interpreting what's
happening in the graph.

1515
01:10:17,160 --> 01:10:20,460
the graph knows no difference.

1516
01:10:20,460 --> 01:10:23,010
This is useful, of course,
because your output

1517
01:10:23,010 --> 01:10:25,120
is the next vertex's
input probably

1518
01:10:25,120 --> 01:10:28,440
if you're building a
bunch of ANDS and ORs.

1519
01:10:28,440 --> 01:10:30,330
If you're building
a regular circuit.

1520
01:10:30,330 --> 01:10:33,120
So you want that definition
to be asymmetric.

1521
01:10:33,120 --> 01:10:35,772
It gets a little bit
confusing, and we

1522
01:10:35,772 --> 01:10:37,730
will spend a lot more
time on constraint logic.

1523
01:10:37,730 --> 01:10:40,260
This is more of a teaser.

1524
01:10:40,260 --> 01:10:44,550
But that's just in
the naming of things.

1525
01:10:44,550 --> 01:10:45,880
Naming of true and false.

1526
01:10:45,880 --> 01:10:46,380
OK.

1527
01:10:46,380 --> 01:10:51,780
So constraint logic, let's say,
what's the decision problem?

1528
01:10:51,780 --> 01:10:54,480
I give you such a graph.

1529
01:10:54,480 --> 01:10:58,810
Notice every vertex is either
an AND, two red and a blue,

1530
01:10:58,810 --> 01:11:00,590
or an OR, three blues.

1531
01:11:00,590 --> 01:11:04,090
And I want to know, can
I reverse that edge?

1532
01:11:04,090 --> 01:11:07,230
This is actually a crossover
gadget if you're curious.

1533
01:11:07,230 --> 01:11:08,840
In this world,
crossover gadgets,

1534
01:11:08,840 --> 01:11:11,500
you can just build
using ANDs and ORs.

1535
01:11:11,500 --> 01:11:12,930
There's no NOTs in this world.

1536
01:11:12,930 --> 01:11:15,330
NOTs don't even make
sense because you

1537
01:11:15,330 --> 01:11:16,790
can't force anything.

1538
01:11:16,790 --> 01:11:21,250
But it turns out this
problem is PSPACE complete.

1539
01:11:21,250 --> 01:11:25,560
So even harder than
3SAT, assuming NP

1540
01:11:25,560 --> 01:11:28,310
does not equal PSPACE.

1541
01:11:28,310 --> 01:11:31,690
And the cool thing is
once you have developed

1542
01:11:31,690 --> 01:11:35,140
all that infrastructure, if you
want to take a puzzle like Rush

1543
01:11:35,140 --> 01:11:36,870
Hour-- so these are cars.

1544
01:11:36,870 --> 01:11:39,355
Each car can slide in
the direction of the car,

1545
01:11:39,355 --> 01:11:43,795
no turns allowed, and your
goal is to get some car out,

1546
01:11:43,795 --> 01:11:47,290
or to move some car
at all, let's say,

1547
01:11:47,290 --> 01:11:48,530
I need to do two things.

1548
01:11:48,530 --> 01:11:52,490
I need to construct an AND
date and construct an OR gate,

1549
01:11:52,490 --> 01:11:55,480
and then I need to check
that they fit together.

1550
01:11:55,480 --> 01:11:58,100
So let me convince
you this is an AND

1551
01:11:58,100 --> 01:11:59,920
with this kind of orientation.

1552
01:11:59,920 --> 01:12:03,870
And yeah.

1553
01:12:03,870 --> 01:12:07,320
So this is going to
feel a little backwards.

1554
01:12:07,320 --> 01:12:11,070
Inward pointing means
that the block is out,

1555
01:12:11,070 --> 01:12:14,190
and outward pointing
means the block is in.

1556
01:12:14,190 --> 01:12:16,789
Ignore this picture
for the moment.

1557
01:12:16,789 --> 01:12:18,330
What happens here
is that if you want

1558
01:12:18,330 --> 01:12:21,210
to push C into this
gadget, imagine

1559
01:12:21,210 --> 01:12:23,030
the dark gray blocks are rigid.

1560
01:12:23,030 --> 01:12:24,330
They can't they can never move.

1561
01:12:24,330 --> 01:12:26,070
That's going to be true.

1562
01:12:26,070 --> 01:12:27,610
We'll see why in a moment.

1563
01:12:27,610 --> 01:12:29,820
So then it's just about
these inner guys moving.

1564
01:12:29,820 --> 01:12:32,140
If you want to
move C in one unit,

1565
01:12:32,140 --> 01:12:34,910
that will be possible if
and only if A moves out

1566
01:12:34,910 --> 01:12:37,730
and B moves out by one unit.

1567
01:12:37,730 --> 01:12:40,210
A moves out by one unit,
B moves out by one unit,

1568
01:12:40,210 --> 01:12:45,420
then this block can slide here,
this block can slide here.

1569
01:12:45,420 --> 01:12:50,100
This block can slide one,
this block can slide two,

1570
01:12:50,100 --> 01:12:52,800
and then C can move in one.

1571
01:12:52,800 --> 01:12:56,250
On the other hand, this
is an OR gate, OR vertex.

1572
01:12:56,250 --> 01:13:00,700
If A moves out one
or B moves out one,

1573
01:13:00,700 --> 01:13:04,040
then either E can move down,
or this guy can move down.

1574
01:13:04,040 --> 01:13:05,630
Once either of
those moves down, D

1575
01:13:05,630 --> 01:13:07,629
can move all the way to
the right or all the way

1576
01:13:07,629 --> 01:13:11,150
to the left, and then
C can move down one.

1577
01:13:11,150 --> 01:13:13,610
This is called a protected Or.

1578
01:13:13,610 --> 01:13:14,650
Small, subtle detail.

1579
01:13:14,650 --> 01:13:17,690
If A and B move out, then
everything can fall apart.

1580
01:13:17,690 --> 01:13:22,856
So basically, there's
a proof in this book

1581
01:13:22,856 --> 01:13:24,730
that says you don't need
to worry about that.

1582
01:13:24,730 --> 01:13:26,840
We can guarantee
that we'll never

1583
01:13:26,840 --> 01:13:28,770
have both A and B move out.

1584
01:13:28,770 --> 01:13:30,730
Only one of them will happen.

1585
01:13:30,730 --> 01:13:33,350
That's the protected part.

1586
01:13:33,350 --> 01:13:35,860
So that's basically the
proof of PSPACE-completeness

1587
01:13:35,860 --> 01:13:36,866
in two pictures.

1588
01:13:36,866 --> 01:13:38,740
This is the cool thing
about constraint logic

1589
01:13:38,740 --> 01:13:41,010
you don't need a crossover
gadget because those always

1590
01:13:41,010 --> 01:13:42,529
happen for free.

1591
01:13:42,529 --> 01:13:45,070
You just need to check that you
can fit the gadgets together.

1592
01:13:45,070 --> 01:13:47,870
And this is the intended
tiling to fit them together.

1593
01:13:47,870 --> 01:13:51,850
And you can check that as long
the box only move at most one

1594
01:13:51,850 --> 01:13:56,640
unit at any time, then
these gray regions are solid

1595
01:13:56,640 --> 01:13:58,170
all the way through.

1596
01:13:58,170 --> 01:14:00,820
I think I need to add
some more filler here.

1597
01:14:00,820 --> 01:14:04,390
And therefore, the gray
blocks can never move.

1598
01:14:04,390 --> 01:14:07,390
And so then, you can analyze
each gadget one at a time

1599
01:14:07,390 --> 01:14:13,590
and construct any constraint
logic graph in this way.

1600
01:14:16,410 --> 01:14:17,450
Questions?

1601
01:14:17,450 --> 01:14:18,090
Yeah?

1602
01:14:18,090 --> 01:14:23,420
AUDIENCE: So for that
graph orientation problem,

1603
01:14:23,420 --> 01:14:25,510
I do not fully understand.

1604
01:14:25,510 --> 01:14:27,116
So you're given a graph--

1605
01:14:27,116 --> 01:14:29,240
PROFESSOR: You're given a
graph and an orientation,

1606
01:14:29,240 --> 01:14:32,676
and you want to know, can
I reverse this one edge?

1607
01:14:32,676 --> 01:14:34,050
So in this world,
it means you're

1608
01:14:34,050 --> 01:14:37,570
given an initial placement
of all the blocks,

1609
01:14:37,570 --> 01:14:40,170
and you know whether each thing
is in or out, because you know

1610
01:14:40,170 --> 01:14:43,170
whether the edge is
pointed to the left

1611
01:14:43,170 --> 01:14:44,170
or pointed to the right.

1612
01:14:44,170 --> 01:14:46,770
And you want to know, can
I move this one block?

1613
01:14:46,770 --> 01:14:47,510
AUDIENCE: OK.

1614
01:14:47,510 --> 01:14:50,424
And then for this graph,
you satisfied the property

1615
01:14:50,424 --> 01:14:53,710
that each vertex has at least
two units [? of input. ?]

1616
01:14:53,710 --> 01:14:56,600
PROFESSOR: Yes, the
input-oriented graph

1617
01:14:56,600 --> 01:14:58,780
should already
satisfy the invariant.

1618
01:14:58,780 --> 01:15:02,490
And then at every
move you do, you

1619
01:15:02,490 --> 01:15:04,721
have to also satisfy
the invariant.

1620
01:15:04,721 --> 01:15:07,012
AUDIENCE: Can you give a
small example of a graph which

1621
01:15:07,012 --> 01:15:08,250
satisfies that [INAUDIBLE]?

1622
01:15:08,250 --> 01:15:10,590
PROFESSOR: A small example.

1623
01:15:10,590 --> 01:15:13,860
Like this one?

1624
01:15:13,860 --> 01:15:15,520
This is not a single graph.

1625
01:15:15,520 --> 01:15:19,940
But if I connect this edge to
here, and this edge to here,

1626
01:15:19,940 --> 01:15:23,680
that will satisfy the property.

1627
01:15:23,680 --> 01:15:25,510
And it's one graph.

1628
01:15:25,510 --> 01:15:27,120
I don't have a small
example offhand

1629
01:15:27,120 --> 01:15:28,790
but I think you could make.

1630
01:15:28,790 --> 01:15:32,610
One

1631
01:15:32,610 --> 01:15:34,110
It's an interesting
question, what's

1632
01:15:34,110 --> 01:15:36,660
the smallest satisfied graph?

1633
01:15:36,660 --> 01:15:41,290
Probably 10 vertices or
something should suffice.

1634
01:15:41,290 --> 01:15:43,850
I should put it on
the problem set.

1635
01:15:43,850 --> 01:15:44,390
But later.

1636
01:15:44,390 --> 01:15:46,265
We'll talk about constraint
logic more later.

1637
01:15:48,730 --> 01:15:49,415
More questions?

1638
01:15:52,680 --> 01:15:53,640
So we did a lot.

1639
01:15:53,640 --> 01:15:55,970
We proved Mario is NP-complete.

1640
01:15:55,970 --> 01:15:57,410
I mean, some hand
waving involved.

1641
01:15:57,410 --> 01:16:01,630
We proved that Rush
Hour is PSPACE-complete

1642
01:16:01,630 --> 01:16:04,240
if you believe that constraint
logic PSPACE-complete.

1643
01:16:04,240 --> 01:16:07,180
In general, this whole
class is about reductions,

1644
01:16:07,180 --> 01:16:08,730
about taking a
known hard problem

1645
01:16:08,730 --> 01:16:11,290
and converting it
into your problem.

1646
01:16:11,290 --> 01:16:17,570
We will see a ton of them, and
each kind of type of problem

1647
01:16:17,570 --> 01:16:19,480
has a different flavor.

1648
01:16:19,480 --> 01:16:22,800
There's a whole range of
different 3SAT proofs.

1649
01:16:22,800 --> 01:16:24,320
This is not the
only form of 3SAT.

1650
01:16:24,320 --> 01:16:27,380
There are probably
a dozen of them .

1651
01:16:27,380 --> 01:16:29,890
But they all follow
the same pattern, which

1652
01:16:29,890 --> 01:16:32,799
is come up with a clause gadget,
come up with a variable gadget,

1653
01:16:32,799 --> 01:16:34,590
come up with ways to
connect them together.

1654
01:16:34,590 --> 01:16:36,400
And that's a very
useful way of thinking

1655
01:16:36,400 --> 01:16:38,330
about things for some problems.

1656
01:16:38,330 --> 01:16:42,014
And then for other problems,
you might use things

1657
01:16:42,014 --> 01:16:42,930
like constraint logic.

1658
01:16:42,930 --> 01:16:44,635
Constraint logic
is most relevant

1659
01:16:44,635 --> 01:16:46,520
when it's designed
around games and puzzles,

1660
01:16:46,520 --> 01:16:48,992
but it comes up in
other scenarios too.

1661
01:16:48,992 --> 01:16:52,030
I think in graph
labeling, there have

1662
01:16:52,030 --> 01:16:53,670
been proofs of
PSPACE-completeness

1663
01:16:53,670 --> 01:16:56,790
using constraint logic.

1664
01:16:56,790 --> 01:16:58,852
Next class, we'll
talk about a problem

1665
01:16:58,852 --> 01:17:01,310
called three partition, which
is really useful for problems

1666
01:17:01,310 --> 01:17:04,940
that involve numbers and adding
up numbers, where 3SAT isn't

1667
01:17:04,940 --> 01:17:09,244
really useful but three
partition turns out

1668
01:17:09,244 --> 01:17:10,160
to be the right thing.

1669
01:17:10,160 --> 01:17:13,520
So that will be next.

1670
01:17:13,520 --> 01:17:16,040
And that's all for today.