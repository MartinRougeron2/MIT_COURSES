1
00:00:00,080 --> 00:00:02,430
The following content is
provided under a Creative

2
00:00:02,430 --> 00:00:03,810
Commons license.

3
00:00:03,810 --> 00:00:06,060
Your support will help
MIT OpenCourseWare

4
00:00:06,060 --> 00:00:10,150
continue to offer high quality
educational resources for free.

5
00:00:10,150 --> 00:00:12,690
To make a donation or to
view additional materials

6
00:00:12,690 --> 00:00:16,600
from hundreds of MIT courses,
visit MIT OpenCourseWare

7
00:00:16,600 --> 00:00:17,330
at ocw.mit.edu.

8
00:00:25,955 --> 00:00:26,830
PROFESSOR: All right.

9
00:00:26,830 --> 00:00:30,660
So today we finish our
game characterization.

10
00:00:30,660 --> 00:00:32,310
We have this giant table.

11
00:00:32,310 --> 00:00:37,020
We've done two players, zero
players, one player, of course.

12
00:00:37,020 --> 00:00:38,260
That's the oldest.

13
00:00:38,260 --> 00:00:41,110
Today we're going to do
team imperfect information

14
00:00:41,110 --> 00:00:43,870
games, which when you
have a polynomial bound

15
00:00:43,870 --> 00:00:46,340
on the number of moves,
you get NEXPTIME--

16
00:00:46,340 --> 00:00:48,240
nondeterministic
exponential time.

17
00:00:48,240 --> 00:00:50,730
This is the exponential
version of NP.

18
00:00:50,730 --> 00:00:54,535
And for games with unbounded
number of moves-- normally,

19
00:00:54,535 --> 00:00:56,660
I would say exponentially
many moves, but, in fact,

20
00:00:56,660 --> 00:00:58,680
this will be really
unbounded, could

21
00:00:58,680 --> 00:01:03,550
be close to infinitely many
moves-- we get Undecidability,

22
00:01:03,550 --> 00:01:05,810
so no algorithm,
whatsoever, to solve it.

23
00:01:05,810 --> 00:01:09,140
We don't know any natural
games in these classes.

24
00:01:09,140 --> 00:01:10,990
But I have a couple of
question marks here.

25
00:01:10,990 --> 00:01:14,670
Bridge is an example of a game
with imperfect information

26
00:01:14,670 --> 00:01:17,390
and teams in one hand.

27
00:01:17,390 --> 00:01:18,560
And it has bounded play.

28
00:01:18,560 --> 00:01:20,940
Once you play your cards--
all of the cards are down--

29
00:01:20,940 --> 00:01:21,700
you're done.

30
00:01:21,700 --> 00:01:23,950
So potentially, it
falls in this class.

31
00:01:23,950 --> 00:01:26,340
Although, I don't know if
Bridge is sophisticated enough

32
00:01:26,340 --> 00:01:30,280
or-- it depends on your
notion of the bidding rules

33
00:01:30,280 --> 00:01:32,800
and what can be
communicated there.

34
00:01:32,800 --> 00:01:35,830
On the other hand, for
the unbounded game,

35
00:01:35,830 --> 00:01:38,630
one candidate problem is
called Rengo Kriegspiel.

36
00:01:38,630 --> 00:01:40,720
Kriegspiel is blind chess.

37
00:01:40,720 --> 00:01:44,040
Rengo Kriegspiel is
blind Go with teams.

38
00:01:44,040 --> 00:01:46,400
So there are two black
players, two white players.

39
00:01:46,400 --> 00:01:48,401
And you make moves
without knowing

40
00:01:48,401 --> 00:01:50,400
what the other moves of
any of the other players

41
00:01:50,400 --> 00:01:52,191
are, usually by writing
on a piece of paper

42
00:01:52,191 --> 00:01:54,230
and giving it to some
referee who tells you

43
00:01:54,230 --> 00:01:57,390
whether that was valid.

44
00:01:57,390 --> 00:01:59,990
This is a game
people actually play.

45
00:01:59,990 --> 00:02:02,770
And I'm told-- I know
Bob Hearn has played it.

46
00:02:02,770 --> 00:02:05,790
He likes playing Go.

47
00:02:05,790 --> 00:02:08,919
But it's open, whether that
problem is Undecidable.

48
00:02:08,919 --> 00:02:10,789
Potentially, yes.

49
00:02:10,789 --> 00:02:13,080
That seems more likely.

50
00:02:13,080 --> 00:02:15,710
And then finally, one other
cell that we didn't do,

51
00:02:15,710 --> 00:02:17,300
which I'll get to
after those two,

52
00:02:17,300 --> 00:02:22,520
is this box, which sounds
pretty boring because it's just

53
00:02:22,520 --> 00:02:26,740
polynomial time things--
polynomial bounded zero player

54
00:02:26,740 --> 00:02:27,250
games.

55
00:02:27,250 --> 00:02:30,290
It's just like Game of Life
running for a polynomial amount

56
00:02:30,290 --> 00:02:31,050
of time.

57
00:02:31,050 --> 00:02:34,640
You can generate-- I mean,
you can solve those problems

58
00:02:34,640 --> 00:02:35,476
in polynomial time.

59
00:02:35,476 --> 00:02:37,850
But there's a stronger sense
in which all polynomial time

60
00:02:37,850 --> 00:02:40,730
problems can be represented,
say, by Game of Life.

61
00:02:40,730 --> 00:02:43,720
And this, actually, is
relevant to parallel computing.

62
00:02:43,720 --> 00:02:46,350
And it essentially says,
there's no good way

63
00:02:46,350 --> 00:02:49,870
to parallelize Game of
Life, among other problems.

64
00:02:49,870 --> 00:02:52,061
So I mentioned that way
back in lecture one.

65
00:02:52,061 --> 00:02:53,560
And a lot of people
said, oh, what's

66
00:02:53,560 --> 00:02:55,020
this P-completeness business?

67
00:02:55,020 --> 00:02:57,850
And so today we will
cover that, as well.

68
00:02:57,850 --> 00:03:02,990
But let's start with
NEXPTIME and Undecidability.

69
00:03:02,990 --> 00:03:04,790
Let's start with a bounded case.

70
00:03:13,070 --> 00:03:16,220
So in the bounded case,
there's this cool paper

71
00:03:16,220 --> 00:03:18,680
by Peterson and
Reif, introducing

72
00:03:18,680 --> 00:03:21,960
a problem variation of QSAT.

73
00:03:27,190 --> 00:03:29,660
Remember, QSAT,
also known as QBF.

74
00:03:29,660 --> 00:03:30,810
So this is DQBF.

75
00:03:33,580 --> 00:03:36,660
And it's a funny problem.

76
00:03:36,660 --> 00:03:40,020
First, I'll phrase it
as a formula problem.

77
00:03:40,020 --> 00:03:42,120
And then I'll talk
about it as a game.

78
00:03:58,630 --> 00:04:03,210
So normally, in QSAT QBF, we
have N alternating quantifiers.

79
00:04:03,210 --> 00:04:04,910
And that's PSACE complete.

80
00:04:04,910 --> 00:04:09,330
And every quantifier can depend
on all of the previous values.

81
00:04:09,330 --> 00:04:10,900
But now we're going
to have two sort

82
00:04:10,900 --> 00:04:13,470
of in parallel
existential quantifiers.

83
00:04:13,470 --> 00:04:16,171
So we have two universal--
I should mention the capital

84
00:04:16,171 --> 00:04:16,670
letters.

85
00:04:16,670 --> 00:04:17,836
That's a bunch of variables.

86
00:04:17,836 --> 00:04:21,000
So there's like N bits
here, N bits here that

87
00:04:21,000 --> 00:04:23,256
has to work for all
choices of those.

88
00:04:23,256 --> 00:04:24,380
Why do I separate them out?

89
00:04:24,380 --> 00:04:26,710
Because over here, I'm
going to separate them out.

90
00:04:26,710 --> 00:04:30,670
And Y1-- the choice of Y1 is
only allowed to depend on X1.

91
00:04:30,670 --> 00:04:35,029
And the choice of Y2 is only
allowed to depend on X2.

92
00:04:35,029 --> 00:04:36,570
And then we're going
to have some CNF

93
00:04:36,570 --> 00:04:38,990
formula on the X1, X2, Y1, Y2.

94
00:04:47,140 --> 00:04:52,480
So we can think of that
as this is one player.

95
00:04:52,480 --> 00:04:53,480
It could be two players.

96
00:04:53,480 --> 00:04:56,100
But it doesn't really matter.

97
00:04:56,100 --> 00:04:57,770
So make it one-- simpler.

98
00:04:57,770 --> 00:04:59,380
It's going to be a
three player game.

99
00:04:59,380 --> 00:05:02,300
Black makes these choices.

100
00:05:02,300 --> 00:05:09,400
And then white player
1 chooses the Y1s.

101
00:05:09,400 --> 00:05:12,610
And the private information
aspect of this game

102
00:05:12,610 --> 00:05:16,420
is that the white player one
can only see the X1 variables--

103
00:05:16,420 --> 00:05:18,904
choices made by black.

104
00:05:18,904 --> 00:05:20,320
Maybe it's more
intuitive to think

105
00:05:20,320 --> 00:05:21,570
of this as a four player game.

106
00:05:21,570 --> 00:05:22,780
There are two black players.

107
00:05:22,780 --> 00:05:25,270
And the white 1 player
can see the values chosen

108
00:05:25,270 --> 00:05:27,210
by the black 1 player
but not the values

109
00:05:27,210 --> 00:05:28,980
chosen by the black 2 player.

110
00:05:28,980 --> 00:05:33,860
And then, over here, we have
white player two, who can only

111
00:05:33,860 --> 00:05:36,570
see the variables chosen-- X2.

112
00:05:36,570 --> 00:05:37,070
Question?

113
00:05:37,070 --> 00:05:39,319
AUDIENCE: Does the black
team have full information?

114
00:05:39,319 --> 00:05:41,110
PROFESSOR: Black team
has full information.

115
00:05:41,110 --> 00:05:42,526
I mean, the black
team goes first.

116
00:05:42,526 --> 00:05:44,514
So it doesn't,
obviously, see Y1 and Y2.

117
00:05:44,514 --> 00:05:45,680
But they can see each other.

118
00:05:45,680 --> 00:05:46,180
Yeah.

119
00:05:46,180 --> 00:05:48,926
So X2 can see X1.

120
00:05:48,926 --> 00:05:49,830
Yeah.

121
00:05:49,830 --> 00:05:52,690
So if I don't write a
parenthetical dependency,

122
00:05:52,690 --> 00:05:55,630
then it can depend
on everything.

123
00:05:55,630 --> 00:05:56,130
Yeah.

124
00:05:56,130 --> 00:05:57,320
Really, this is one player.

125
00:05:57,320 --> 00:06:01,111
So they get to choose
everything in the X [INAUDIBLE].

126
00:06:01,111 --> 00:06:01,610
OK?

127
00:06:01,610 --> 00:06:03,460
So then the question
is given this--

128
00:06:03,460 --> 00:06:08,580
I mean, this quantified
formula's equivalent to saying,

129
00:06:08,580 --> 00:06:16,790
can white force a
win, where white wins

130
00:06:16,790 --> 00:06:19,170
if that formula is satisfied?

131
00:06:19,170 --> 00:06:21,830
And white collectively
needs to make these choices.

132
00:06:21,830 --> 00:06:24,300
But it's acting as a team
with impartial information.

133
00:06:24,300 --> 00:06:26,010
So it's not acting
as a single player

134
00:06:26,010 --> 00:06:29,150
anymore, unlike when we
had full information.

135
00:06:29,150 --> 00:06:32,590
Then three players
was the same as two.

136
00:06:32,590 --> 00:06:33,380
OK?

137
00:06:33,380 --> 00:06:37,210
So let's first observe
that this is in NEXPTIME.

138
00:06:37,210 --> 00:06:39,720
And then, furthermore, the
claim, which I won't prove,

139
00:06:39,720 --> 00:06:43,820
is that this is
NEXPTIME complete.

140
00:06:43,820 --> 00:06:48,410
So the idea is there are only
exponentially many choices

141
00:06:48,410 --> 00:06:50,240
for these variables.

142
00:06:50,240 --> 00:06:54,210
So then I can guess--
both player 1 and player 2

143
00:06:54,210 --> 00:06:56,980
can guess what--
white 1 and white 2

144
00:06:56,980 --> 00:07:00,970
can guess what the possibilities
are for all possible choices

145
00:07:00,970 --> 00:07:02,090
of X1 and X2.

146
00:07:02,090 --> 00:07:04,690
So they're making
exponentially many guesses.

147
00:07:04,690 --> 00:07:09,290
For every state of X1, X2, guess
what the right strategy is.

148
00:07:09,290 --> 00:07:14,290
And then just combine--
then check whether everyone

149
00:07:14,290 --> 00:07:16,070
plays properly.

150
00:07:16,070 --> 00:07:18,100
So then white can decide
whether they can win.

151
00:07:22,280 --> 00:07:23,255
That's cool.

152
00:07:26,700 --> 00:07:31,550
This can be reduced to a bounded
team, private information

153
00:07:31,550 --> 00:07:34,920
version of constraint
logic-- TPCL.

154
00:07:34,920 --> 00:07:37,050
Let me define that.

155
00:07:46,150 --> 00:07:53,160
We're going to do this
with three players

156
00:07:53,160 --> 00:07:54,650
And a plane or a graph.

157
00:07:58,070 --> 00:08:01,110
I think just and/or
graph is enough.

158
00:08:01,110 --> 00:08:03,301
But it's a team.

159
00:08:03,301 --> 00:08:05,300
There are going to be,
again, two white players,

160
00:08:05,300 --> 00:08:06,950
one black player.

161
00:08:06,950 --> 00:08:09,680
And it's private
information, meaning

162
00:08:09,680 --> 00:08:13,430
that each edge is marked
as visible to white

163
00:08:13,430 --> 00:08:14,620
or visible to black.

164
00:08:14,620 --> 00:08:16,710
Now, the figures-- it's
a little hard to draw.

165
00:08:16,710 --> 00:08:18,430
So the figures--
the color is just

166
00:08:18,430 --> 00:08:21,430
indicating whether that player
is allowed to flip that edge.

167
00:08:21,430 --> 00:08:23,972
Each player can only flip--
each white player can only

168
00:08:23,972 --> 00:08:24,680
flip white edges.

169
00:08:24,680 --> 00:08:27,880
Black player can only flip
black edges, just like before.

170
00:08:27,880 --> 00:08:30,080
Well, now it's
white team can only

171
00:08:30,080 --> 00:08:31,950
flip-- either of
the white players

172
00:08:31,950 --> 00:08:34,500
can only flip a white edge.

173
00:08:34,500 --> 00:08:38,620
So some edges are
flippable by two players.

174
00:08:38,620 --> 00:08:40,890
But then, in addition, some
edges-- some white edges

175
00:08:40,890 --> 00:08:42,880
are going to be marked
as invisible to black.

176
00:08:42,880 --> 00:08:44,230
And some black edges
are going to be

177
00:08:44,230 --> 00:08:45,438
marked as invisible to white.

178
00:08:45,438 --> 00:08:47,960
And furthermore, you can say
invisible to this white player

179
00:08:47,960 --> 00:08:49,880
or this white player.

180
00:08:49,880 --> 00:08:50,380
OK?

181
00:08:50,380 --> 00:08:52,260
So it's a little
bit more general.

182
00:08:52,260 --> 00:08:54,630
And the rules of the
game are pretty simple.

183
00:08:54,630 --> 00:08:56,720
You can make moves
just like before.

184
00:08:56,720 --> 00:09:02,350
But you must be able to know
that that move is legal.

185
00:09:07,660 --> 00:09:09,630
So unlike Rengo
Kriegspiel, you're

186
00:09:09,630 --> 00:09:12,385
not allowed to make
impossible moves.

187
00:09:15,920 --> 00:09:20,080
You must know, based on the
information that you can see,

188
00:09:20,080 --> 00:09:22,794
that the movie is valid.

189
00:09:22,794 --> 00:09:24,710
There are probably other
variations that work.

190
00:09:24,710 --> 00:09:27,320
But this is a clean
one to work with.

191
00:09:27,320 --> 00:09:29,240
So if you can see
all of the edges,

192
00:09:29,240 --> 00:09:31,090
or you see that there's enough
incoming white to an edge,

193
00:09:31,090 --> 00:09:33,548
then you can reverse one of
the ones you have control over.

194
00:09:35,950 --> 00:09:40,320
So this problem-- I mean,
so a funny thing about DQBF

195
00:09:40,320 --> 00:09:42,920
is that there's sort of
only one round to the game--

196
00:09:42,920 --> 00:09:45,530
I mean, black plays,
white plays, white plays,

197
00:09:45,530 --> 00:09:49,260
and then you see who won--
whereas most games we think

198
00:09:49,260 --> 00:09:50,910
of as having many rounds.

199
00:09:50,910 --> 00:09:54,420
And in particular, bounded
TPCL has many rounds.

200
00:09:54,420 --> 00:09:55,500
They play in round robin.

201
00:09:55,500 --> 00:09:58,040
You've got black, white 1, white
2, black, white 1, white two.

202
00:09:58,040 --> 00:09:59,914
And you play in that
sequence, over and over.

203
00:09:59,914 --> 00:10:02,220
Each turn, someone's just
reversing a single edge,

204
00:10:02,220 --> 00:10:05,720
whereas over here, you're
choosing a ton of variables.

205
00:10:05,720 --> 00:10:10,310
Turns out this problem
is also in NEXPTIME,

206
00:10:10,310 --> 00:10:17,330
essentially because if there is
a winning strategy for white,

207
00:10:17,330 --> 00:10:21,330
over here, that winning
strategy is deterministic.

208
00:10:21,330 --> 00:10:24,910
And it's just a function
of the visible state.

209
00:10:24,910 --> 00:10:27,980
And there are at most
N different edges

210
00:10:27,980 --> 00:10:29,130
that you can see.

211
00:10:29,130 --> 00:10:31,160
So the number of possible
states is exponential.

212
00:10:31,160 --> 00:10:36,070
So at the beginning, you
just guess your strategy.

213
00:10:36,070 --> 00:10:38,050
That's exponentially
many bits to guess.

214
00:10:38,050 --> 00:10:40,010
So in NEXPTIME, you can do that.

215
00:10:40,010 --> 00:10:42,289
And then you just play
deterministically,

216
00:10:42,289 --> 00:10:43,080
with that strategy.

217
00:10:43,080 --> 00:10:45,530
So even though the game may
run for a very long time,

218
00:10:45,530 --> 00:10:47,394
and you do many,
many rounds, still,

219
00:10:47,394 --> 00:10:49,685
the information you need to
guess was only exponential.

220
00:10:49,685 --> 00:10:51,630
So you can do this in NEXPTIME.

221
00:10:51,630 --> 00:10:53,610
So it's a funny thing here.

222
00:10:53,610 --> 00:10:55,450
In this particular
world, unlike all

223
00:10:55,450 --> 00:10:59,470
of the other cells
of that matrix,

224
00:10:59,470 --> 00:11:02,250
one round versus many
rounds is the same.

225
00:11:02,250 --> 00:11:05,550
You get NEXPTIME
completeness in both cases.

226
00:11:05,550 --> 00:11:06,050
OK.

227
00:11:06,050 --> 00:11:12,842
So let me tell you how we reduce
from DQBF to bounded TPCL.

228
00:11:12,842 --> 00:11:13,550
So many acronyms.

229
00:11:17,190 --> 00:11:21,580
So the idea's pretty simple.

230
00:11:21,580 --> 00:11:25,090
Again, we want
black to play first.

231
00:11:25,090 --> 00:11:27,690
So there's a bunch of
black variables, here,

232
00:11:27,690 --> 00:11:30,280
which are represented by this.

233
00:11:30,280 --> 00:11:32,070
These two figures
are almost the same.

234
00:11:32,070 --> 00:11:35,090
Just these edges are blacked
down here and white down here.

235
00:11:35,090 --> 00:11:37,885
That's going to correspond
to the variable setting.

236
00:11:37,885 --> 00:11:40,650
In this context, we only want
variables to be set once.

237
00:11:40,650 --> 00:11:44,850
You don't get to reset them
because it's a bounded game.

238
00:11:44,850 --> 00:11:47,010
As in all of the bounded
constraint logic games,

239
00:11:47,010 --> 00:11:48,760
you can only flip
each edge once.

240
00:11:48,760 --> 00:11:49,300
Question?

241
00:11:49,300 --> 00:11:50,701
AUDIENCE: It's kind of a
question about your earlier

242
00:11:50,701 --> 00:11:52,492
point, but could you
clarify the difference

243
00:11:52,492 --> 00:11:55,007
between why having one
round of one of the games

244
00:11:55,007 --> 00:11:59,869
is equivalent to having
all-around [INAUDIBLE] game?

245
00:11:59,869 --> 00:12:01,660
PROFESSOR: I don't have
an intuitive reason

246
00:12:01,660 --> 00:12:06,710
why-- only that this game
is in NEXPTIME and this game

247
00:12:06,710 --> 00:12:08,150
is NEXPTIME complete.

248
00:12:08,150 --> 00:12:09,970
I mean, they both are
NEXPTIME complete.

249
00:12:09,970 --> 00:12:12,970
So in that sense,
they're equivalent.

250
00:12:12,970 --> 00:12:13,780
Yeah.

251
00:12:13,780 --> 00:12:15,560
So we're going to
simulate this one round

252
00:12:15,560 --> 00:12:19,440
game with multiple
rounds, over here.

253
00:12:19,440 --> 00:12:20,110
But yeah.

254
00:12:20,110 --> 00:12:23,130
It's a little bit odd that
alternation doesn't help.

255
00:12:23,130 --> 00:12:24,580
It doesn't give you more power.

256
00:12:24,580 --> 00:12:26,770
All of the other game
settings that it does.

257
00:12:26,770 --> 00:12:29,600
So it's just a weird
thing about team.

258
00:12:29,600 --> 00:12:30,410
Yeah.

259
00:12:30,410 --> 00:12:34,692
AUDIENCE: So are you [INAUDIBLE]
kind of rely on the fact

260
00:12:34,692 --> 00:12:37,320
that white doesn't learn
anything from black's moves

261
00:12:37,320 --> 00:12:39,290
when black moves on
an invisible edge?

262
00:12:39,290 --> 00:12:39,790
Sorry.

263
00:12:39,790 --> 00:12:41,150
It seems like in some
board configurations,

264
00:12:41,150 --> 00:12:42,360
if black moves on
an invisible edge,

265
00:12:42,360 --> 00:12:43,970
you can actually
learn something based

266
00:12:43,970 --> 00:12:48,211
on what moves were allowed,
and not allowed, for black.

267
00:12:48,211 --> 00:12:49,960
PROFESSOR: Maybe I
should say that passing

268
00:12:49,960 --> 00:12:52,030
is allowed in this game.

269
00:12:52,030 --> 00:12:55,249
Otherwise, the fact that you
moved does tell you something.

270
00:12:55,249 --> 00:12:56,790
But if you're always
allowed to pass,

271
00:12:56,790 --> 00:12:59,170
you really have no idea
whether something happened,

272
00:12:59,170 --> 00:13:00,501
except by what was visible.

273
00:13:00,501 --> 00:13:01,000
Yeah.

274
00:13:01,000 --> 00:13:03,960
So that's-- make explicit,
passing is allowed.

275
00:13:09,040 --> 00:13:12,301
Yeah, these are a bit subtle.

276
00:13:12,301 --> 00:13:12,800
OK.

277
00:13:12,800 --> 00:13:16,880
So the intent is, first, we
let black choose variables,

278
00:13:16,880 --> 00:13:19,150
either by flipping true edge,
flipping the false edge.

279
00:13:19,150 --> 00:13:21,320
We want to set it up
so you can't do-- well,

280
00:13:21,320 --> 00:13:23,925
you can't do both because
of this vertex constraint.

281
00:13:23,925 --> 00:13:24,550
So that's cool.

282
00:13:24,550 --> 00:13:28,680
As soon as that
happens, probably, white

283
00:13:28,680 --> 00:13:31,500
will flip this edge and
black will flip this edge.

284
00:13:31,500 --> 00:13:35,890
That's a split, activating--
well, not yet activating

285
00:13:35,890 --> 00:13:40,460
the formula part, but enabling
black to activate the chosen

286
00:13:40,460 --> 00:13:43,630
edge, saying that this
variable has been chosen.

287
00:13:43,630 --> 00:13:47,470
And so black will
sort of output that.

288
00:13:47,470 --> 00:13:50,920
Then in here, so there's
n such variables.

289
00:13:50,920 --> 00:13:53,730
And B1 and B2 are both in here.

290
00:13:53,730 --> 00:13:57,030
And we take the and of
all of those chosen edges.

291
00:13:57,030 --> 00:13:59,770
And that's this chosen wire.

292
00:13:59,770 --> 00:14:02,090
So this-- black is
motivated to do this.

293
00:14:02,090 --> 00:14:04,940
Black wants to set
their variable some way.

294
00:14:04,940 --> 00:14:06,929
And they could, I
guess, set them back

295
00:14:06,929 --> 00:14:07,970
and change the variables.

296
00:14:07,970 --> 00:14:10,150
But there won't be any
motivation to do that.

297
00:14:10,150 --> 00:14:12,370
The goal for black is
to flip this edge, which

298
00:14:12,370 --> 00:14:15,540
is connected by a long path from
the AND of all of the chosen

299
00:14:15,540 --> 00:14:16,040
wires.

300
00:14:16,040 --> 00:14:18,730
So basically, B has to
choose all of the variables,

301
00:14:18,730 --> 00:14:21,350
get this AND to be true,
and then just sit there,

302
00:14:21,350 --> 00:14:23,700
flipping these edges,
until this edge is flipped.

303
00:14:23,700 --> 00:14:28,270
So that's a threat line, once
B has set their variables.

304
00:14:28,270 --> 00:14:30,290
So B is going to
race to do that.

305
00:14:30,290 --> 00:14:32,780
White is going to have
just enough time to satisfy

306
00:14:32,780 --> 00:14:36,740
the formula and flip this
edge if the formula was true,

307
00:14:36,740 --> 00:14:39,030
obviously.

308
00:14:39,030 --> 00:14:42,690
So what happens next--
white will basically

309
00:14:42,690 --> 00:14:46,740
sit there and
twiddle their thumbs,

310
00:14:46,740 --> 00:14:50,026
flipping some useless
edge, until all

311
00:14:50,026 --> 00:14:51,440
of the black variables are set.

312
00:14:51,440 --> 00:14:53,023
They could actually
do something else.

313
00:14:53,023 --> 00:14:55,130
But there's going to
be enough time to wait.

314
00:14:55,130 --> 00:14:56,780
So it's better to wait.

315
00:14:56,780 --> 00:15:01,410
Then the white variables can
depend on the black variables

316
00:15:01,410 --> 00:15:03,500
that it can see.

317
00:15:03,500 --> 00:15:07,840
Obviously, pretty much
all of the edges in here

318
00:15:07,840 --> 00:15:10,045
are visible to only one
of the white players.

319
00:15:10,045 --> 00:15:13,480
If this is a B1
variable, then this

320
00:15:13,480 --> 00:15:15,830
is only visible the white 1.

321
00:15:15,830 --> 00:15:17,700
White 1 can see
that it was chosen

322
00:15:17,700 --> 00:15:19,250
but can't see which
of these edges

323
00:15:19,250 --> 00:15:21,360
got flipped and can't
see which of these edges

324
00:15:21,360 --> 00:15:24,460
got flipped or these ones.

325
00:15:24,460 --> 00:15:24,960
OK?

326
00:15:24,960 --> 00:15:28,220
So that's representing
the visibility.

327
00:15:28,220 --> 00:15:30,410
And so then white will
set their variables,

328
00:15:30,410 --> 00:15:32,670
the same kind of construction.

329
00:15:32,670 --> 00:15:38,640
And once chosen is
activated for both of them,

330
00:15:38,640 --> 00:15:43,210
we take the AND here, and
we trigger the unlock paths.

331
00:15:43,210 --> 00:15:47,110
It's going to unlock the white
1, unlock the white 2, unlock

332
00:15:47,110 --> 00:15:49,830
all of the black variables.

333
00:15:49,830 --> 00:15:55,190
And the unlock part is what
lets you trigger the formula

334
00:15:55,190 --> 00:15:56,330
activation.

335
00:15:56,330 --> 00:16:00,490
So if true was selected
here, and this was flipped,

336
00:16:00,490 --> 00:16:02,740
once the unlock is
flipped, then this guy

337
00:16:02,740 --> 00:16:05,560
can activate and start inputting
all of the true variables

338
00:16:05,560 --> 00:16:06,950
into the formula.

339
00:16:06,950 --> 00:16:09,710
And then white will sit there
and evaluate the formula.

340
00:16:09,710 --> 00:16:14,350
It has just enough time, if it's
satisfied, to flip and be done.

341
00:16:14,350 --> 00:16:17,100
So that's how we
represent dependency QBF.

342
00:16:17,100 --> 00:16:19,800
I mean, it's pretty natural.

343
00:16:19,800 --> 00:16:23,125
It's just some fun stuff
to get these to happen

344
00:16:23,125 --> 00:16:25,050
in essentially two rounds.

345
00:16:25,050 --> 00:16:28,000
The visibility constraints of
the partial-- the privateness

346
00:16:28,000 --> 00:16:31,669
of visible information
makes this part really easy

347
00:16:31,669 --> 00:16:32,210
to implement.

348
00:16:32,210 --> 00:16:34,930
So no big surprises.

349
00:16:34,930 --> 00:16:37,474
Questions?

350
00:16:37,474 --> 00:16:38,950
OK.

351
00:16:38,950 --> 00:16:40,750
Let's go to the
unbounded case, which

352
00:16:40,750 --> 00:16:42,820
is the much more exciting one.

353
00:16:48,520 --> 00:16:53,350
So I mean, Undecidability
is weird and unusual.

354
00:16:53,350 --> 00:16:56,410
It's weird in this
context because this game

355
00:16:56,410 --> 00:16:58,200
has finite resources.

356
00:16:58,200 --> 00:16:59,840
All of our games--
in particular,

357
00:16:59,840 --> 00:17:03,690
in constraint logic-- you
have some graph of size n.

358
00:17:03,690 --> 00:17:06,329
And Undecidability is
about, essentially,

359
00:17:06,329 --> 00:17:10,764
simulating a Turing machine
for arbitrary amounts of time

360
00:17:10,764 --> 00:17:12,055
and arbitrary amounts of space.

361
00:17:14,854 --> 00:17:16,020
It's bigger than 2 to the n.

362
00:17:16,020 --> 00:17:17,395
It's bigger than
2 to 2 to the n.

363
00:17:17,395 --> 00:17:18,900
It's bigger than 2 tower.

364
00:17:18,900 --> 00:17:21,500
And it's bigger than
any-- I guess, it's

365
00:17:21,500 --> 00:17:24,240
any computable function of
n is how far you have to go.

366
00:17:24,240 --> 00:17:26,180
So a little bit less
than busy beaver.

367
00:17:28,710 --> 00:17:30,490
That's a lot of space.

368
00:17:30,490 --> 00:17:35,179
So in game graph,
we can't represent

369
00:17:35,179 --> 00:17:37,470
the state of the machine that
we're trying to simulate.

370
00:17:37,470 --> 00:17:43,520
So I should say-- we haven't
done Undecidability at all,

371
00:17:43,520 --> 00:17:48,850
but the canonical
problem to start from

372
00:17:48,850 --> 00:17:50,770
is a halting problem.

373
00:17:50,770 --> 00:17:53,470
You're given a Turing machine.

374
00:17:53,470 --> 00:17:55,490
And here, I'd like
to say algorithm,

375
00:17:55,490 --> 00:17:58,090
but we need some model
of the machine growing

376
00:17:58,090 --> 00:17:59,610
to arbitrarily large sizes.

377
00:17:59,610 --> 00:18:03,770
And this Turing machine
is really ideal for this.

378
00:18:03,770 --> 00:18:06,735
Given the Turing machine,
does it ever halt?

379
00:18:12,040 --> 00:18:16,170
So remember, a Turing
machine, you have some tape.

380
00:18:16,170 --> 00:18:19,770
Let's say, initially, all of
the tape squares are empty.

381
00:18:19,770 --> 00:18:21,990
You have some pointer
into the tape, starts

382
00:18:21,990 --> 00:18:24,510
at some canonical position.

383
00:18:24,510 --> 00:18:28,010
And you can read and
write squares in the tape.

384
00:18:28,010 --> 00:18:29,480
And you can move left and right.

385
00:18:29,480 --> 00:18:32,300
And that's it.

386
00:18:32,300 --> 00:18:34,480
The feeling, as this
corresponds-- this

387
00:18:34,480 --> 00:18:37,020
includes all
possible computation.

388
00:18:37,020 --> 00:18:39,847
And so deciding whether
this machine will ever

389
00:18:39,847 --> 00:18:41,930
finish-- so there's an
instruction that just says,

390
00:18:41,930 --> 00:18:47,750
halt-- or whether to just
keep going on forever seems--

391
00:18:47,750 --> 00:18:49,460
is provably impossible.

392
00:18:49,460 --> 00:18:51,360
There is no algorithm
to decide that,

393
00:18:51,360 --> 00:18:53,890
essentially because it's an
algorithm to study algorithms.

394
00:18:53,890 --> 00:18:55,940
But I won't prove that here.

395
00:18:55,940 --> 00:18:57,745
I'm going to reduce
from this problem.

396
00:18:57,745 --> 00:19:00,325
And so I need to be able to
simulate a Turing machine

397
00:19:00,325 --> 00:19:02,470
of arbitrary size and time.

398
00:19:05,550 --> 00:19:07,080
Cool.

399
00:19:07,080 --> 00:19:11,480
So while most of the time
I don't show you the source

400
00:19:11,480 --> 00:19:14,967
problem, I think, here, it's
instructive to see-- well,

401
00:19:14,967 --> 00:19:16,800
I guess I'm not proving
this as undecidable.

402
00:19:16,800 --> 00:19:20,720
But it's instructive to see
how we turn this into a game,

403
00:19:20,720 --> 00:19:21,850
with bounded resources.

404
00:19:21,850 --> 00:19:24,940
So before I get to the
constrain logic version,

405
00:19:24,940 --> 00:19:27,660
I'm going to talk about
something called a team

406
00:19:27,660 --> 00:19:37,670
computation game-- this is
from our book, Games, Puzzles,

407
00:19:37,670 --> 00:19:43,260
Computation-- that will allow
us to simulate the halting

408
00:19:43,260 --> 00:19:44,940
problem, but using
finite resources.

409
00:19:44,940 --> 00:19:46,670
This is where the action is.

410
00:19:46,670 --> 00:19:48,240
Going from here to
a constrain logic

411
00:19:48,240 --> 00:19:51,770
is not that hard and
not super interesting.

412
00:19:51,770 --> 00:19:53,390
But this part is
quite interesting.

413
00:19:57,100 --> 00:19:57,600
OK.

414
00:19:57,600 --> 00:19:59,410
So in team computation
game, there's

415
00:19:59,410 --> 00:20:03,000
going to be three players--
one black player, two

416
00:20:03,000 --> 00:20:04,880
white players.

417
00:20:04,880 --> 00:20:09,900
And the instance to the game--
sort of the board set up,

418
00:20:09,900 --> 00:20:16,740
whatever-- is
going to be-- here,

419
00:20:16,740 --> 00:20:19,400
I could use any algorithm
or Turing machine.

420
00:20:19,400 --> 00:20:21,590
It's going to be machine.

421
00:20:21,590 --> 00:20:25,320
And it has some
space bound which

422
00:20:25,320 --> 00:20:28,540
are called k. k is going to
be, essentially, a constant.

423
00:20:28,540 --> 00:20:29,680
But it's part of the input.

424
00:20:32,560 --> 00:20:34,204
And the idea-- if
this is an algorithm,

425
00:20:34,204 --> 00:20:35,370
it starts with blank memory.

426
00:20:35,370 --> 00:20:39,350
If it's a Turing machine,
it starts with a blank tape.

427
00:20:39,350 --> 00:20:42,680
And then we're going to define
black moves and white moves.

428
00:20:45,370 --> 00:20:48,300
So remember, there's
one black player.

429
00:20:48,300 --> 00:20:53,400
And what the black player does,
or what the black player's

430
00:20:53,400 --> 00:20:57,160
forced to do, is run the
algorithm or the machine

431
00:20:57,160 --> 00:21:00,080
for k time steps.

432
00:21:04,580 --> 00:21:06,990
So k obviously is an input.

433
00:21:06,990 --> 00:21:10,380
So black is forced to do that.

434
00:21:10,380 --> 00:21:13,310
Now, that algorithm
may return an answer.

435
00:21:13,310 --> 00:21:16,460
And the answer is always
black wins or white wins.

436
00:21:16,460 --> 00:21:18,489
Or it may not do
anything, in which case

437
00:21:18,489 --> 00:21:19,530
it wants to keep running.

438
00:21:19,530 --> 00:21:21,866
In the next black
move, it's going

439
00:21:21,866 --> 00:21:22,990
to run for another k steps.

440
00:21:22,990 --> 00:21:24,850
And in the next black moves,
it runs for another k steps,

441
00:21:24,850 --> 00:21:25,779
and so on.

442
00:21:25,779 --> 00:21:26,820
Think of k as a constant.

443
00:21:29,550 --> 00:21:37,339
So if there's output from
this algorithm or machine,

444
00:21:37,339 --> 00:21:38,630
that will determine the winner.

445
00:21:45,550 --> 00:21:46,180
OK?

446
00:21:46,180 --> 00:21:50,690
And otherwise, black actually
gets to make a choice.

447
00:21:50,690 --> 00:21:53,000
This was completely forced,
what black had to do here.

448
00:21:53,000 --> 00:21:54,916
You could think of it
as part of black's move.

449
00:21:54,916 --> 00:21:59,680
But it's really-- the game
mechanics make this happen.

450
00:21:59,680 --> 00:22:05,570
And in this case, black can
set two variables-- X1 and X2--

451
00:22:05,570 --> 00:22:10,960
to be anything in
the set A, B. OK?

452
00:22:10,960 --> 00:22:14,530
Black gets to choose two
bits if the machine doesn't

453
00:22:14,530 --> 00:22:16,390
say that the game is over.

454
00:22:16,390 --> 00:22:16,890
OK?

455
00:22:16,890 --> 00:22:18,640
We'll see what those
bits do, in a moment.

456
00:22:23,960 --> 00:22:26,810
So that was black's move.

457
00:22:26,810 --> 00:22:29,070
Now, what about white?

458
00:22:29,070 --> 00:22:32,370
Again, there are two
players-- white 1 and white 2.

459
00:22:32,370 --> 00:22:38,870
And white i is basically blind.

460
00:22:38,870 --> 00:22:42,030
White i can only see Xi.

461
00:22:42,030 --> 00:22:44,504
These Xis are messages
to the white players.

462
00:22:44,504 --> 00:22:45,920
And that's all
that white can see.

463
00:22:45,920 --> 00:22:49,020
White can't see anything
else about the machine.

464
00:22:49,020 --> 00:22:51,350
Good that it knows what
the machine is, knows what

465
00:22:51,350 --> 00:22:52,675
it's doing, probably knows k.

466
00:22:52,675 --> 00:22:54,800
But that's because that's
all part of the instance.

467
00:22:54,800 --> 00:22:59,540
But you don't know anything else
about the state of the machine.

468
00:22:59,540 --> 00:23:01,770
And white can also
do one other thing.

469
00:23:07,770 --> 00:23:11,340
There's one memory cell
in the machine, called M1.

470
00:23:11,340 --> 00:23:12,940
And there's another
one called M2.

471
00:23:12,940 --> 00:23:18,230
And player white i can set Mi.

472
00:23:18,230 --> 00:23:19,770
And so that will
communicate, back

473
00:23:19,770 --> 00:23:23,550
into the machine,
what white i did.

474
00:23:23,550 --> 00:23:27,120
And that is exactly
the move of white i.

475
00:23:27,120 --> 00:23:33,190
White i move is just set Mi.

476
00:23:33,190 --> 00:23:34,860
And I'm not specifying
how big that is.

477
00:23:34,860 --> 00:23:36,830
It's not just a single bit.

478
00:23:36,830 --> 00:23:42,270
It could be some stuff.

479
00:23:42,270 --> 00:23:46,450
In particular, it's going to be
one cell in the Turing machine

480
00:23:46,450 --> 00:23:48,490
we want to simulate,
essentially.

481
00:23:48,490 --> 00:23:51,020
But OK.

482
00:23:51,020 --> 00:23:53,860
So now the question is, does
white have a forced win?

483
00:23:59,020 --> 00:24:02,340
So this is the problem I
want to prove undecidable

484
00:24:02,340 --> 00:24:05,810
by a reduction from
halting problem.

485
00:24:09,702 --> 00:24:10,202
OK.

486
00:24:22,910 --> 00:24:24,930
So is the problem clear?

487
00:24:24,930 --> 00:24:29,330
We have a finite setup, which
is this space k situation,

488
00:24:29,330 --> 00:24:32,490
that the entire state of
the game is, in some sense,

489
00:24:32,490 --> 00:24:36,900
encoded by that-- the state of
that algorithm, it would seem.

490
00:24:39,640 --> 00:24:43,840
And black is just
telling-- in each turn,

491
00:24:43,840 --> 00:24:48,700
white 1 says A or B, white 2, it
says A or B. White 1 and 2 then

492
00:24:48,700 --> 00:24:50,690
respond with some symbol.

493
00:24:50,690 --> 00:24:52,670
And then the game continues.

494
00:24:52,670 --> 00:24:54,700
So a pretty simple setup.

495
00:24:54,700 --> 00:24:58,570
But amazingly, this can
simulate any Turing machine.

496
00:25:01,930 --> 00:25:02,870
So let's do it.

497
00:25:14,700 --> 00:25:16,879
So this algorithm is
going to be a function.

498
00:25:16,879 --> 00:25:18,420
Given the Turing
machine, we're going

499
00:25:18,420 --> 00:25:20,570
to construct the
algorithm, naturally.

500
00:25:20,570 --> 00:25:27,930
So we basically need a
constant space algorithm

501
00:25:27,930 --> 00:25:37,716
to check that the
white players produce--

502
00:25:37,716 --> 00:25:40,960
so the white players are
outputting a strain of symbols.

503
00:25:40,960 --> 00:25:43,210
White 1 is outputting M1 and
then outputting something

504
00:25:43,210 --> 00:25:44,780
else to M1, and so on.

505
00:25:44,780 --> 00:25:48,460
That strain of symbols,
for both white players,

506
00:25:48,460 --> 00:25:52,200
should essentially form a
valid computation history,

507
00:25:52,200 --> 00:25:55,150
an execution trace
of the Turing machine

508
00:25:55,150 --> 00:25:57,120
we want to simulate--
the given Turing machine.

509
00:26:00,585 --> 00:26:02,460
It's a little bit more
complicated than that.

510
00:26:02,460 --> 00:26:04,310
But that's the idea.

511
00:26:42,600 --> 00:26:45,280
And we'd like it to
end in a halt state.

512
00:26:45,280 --> 00:26:47,210
So there are lots
of canonical ways

513
00:26:47,210 --> 00:26:49,820
to write down the state
of the Turing machine.

514
00:26:49,820 --> 00:26:51,370
Basically, you
write down the tape

515
00:26:51,370 --> 00:26:55,240
and what instruction it's on.

516
00:26:55,240 --> 00:26:57,324
And that should be about it.

517
00:26:57,324 --> 00:26:59,240
And we're going to put
a special symbol-- hash

518
00:26:59,240 --> 00:27:00,914
mark-- in between
each of these states.

519
00:27:00,914 --> 00:27:02,830
So this is the state of
the machine at time 0.

520
00:27:02,830 --> 00:27:04,259
It's going to be a blank tape.

521
00:27:04,259 --> 00:27:06,550
And you only have to write
as many symbols as you need.

522
00:27:06,550 --> 00:27:08,820
So in the beginning,
don't write any symbols.

523
00:27:08,820 --> 00:27:12,390
As you start writing stuff to
tape, this will get longer.

524
00:27:12,390 --> 00:27:14,222
And yeah.

525
00:27:14,222 --> 00:27:16,180
And then the goal is to
get it to a halt state.

526
00:27:16,180 --> 00:27:20,050
Each of these states should be
the uniquely determined state

527
00:27:20,050 --> 00:27:22,430
from the previous one, which
is, if I do one instruction,

528
00:27:22,430 --> 00:27:24,072
what happens?

529
00:27:24,072 --> 00:27:24,980
OK?

530
00:27:24,980 --> 00:27:28,300
Now, this is problematic.

531
00:27:28,300 --> 00:27:31,250
So our goal-- we're trying
to design this algorithm

532
00:27:31,250 --> 00:27:36,164
to confirm that these states
are being generated correctly.

533
00:27:36,164 --> 00:27:38,830
That's really hard to do because
we can't compute the next state

534
00:27:38,830 --> 00:27:40,621
from the previous one
because we can't even

535
00:27:40,621 --> 00:27:44,560
store the previous
state in space k.

536
00:27:44,560 --> 00:27:46,200
We have constant space.

537
00:27:46,200 --> 00:27:49,110
Very soon, the state
is going to get huge.

538
00:27:49,110 --> 00:27:51,650
So you think of this as kind
of a streaming [INAUDIBLE]

539
00:27:51,650 --> 00:27:53,640
We're just seeing
these characters go by.

540
00:27:53,640 --> 00:27:56,480
And we can't remember the
entire previous states.

541
00:27:56,480 --> 00:27:59,000
So the fact-- to check
that the next state is

542
00:27:59,000 --> 00:28:02,350
almost the same as the
previous one is very hard.

543
00:28:02,350 --> 00:28:06,280
And that's where we're going
to use this A, B thing.

544
00:28:06,280 --> 00:28:08,930
This is not literally true.

545
00:28:08,930 --> 00:28:11,580
The sequence of
characters-- M1, say--

546
00:28:11,580 --> 00:28:14,670
will not produce a valid state.

547
00:28:14,670 --> 00:28:18,590
Essentially, what we
want player white 1

548
00:28:18,590 --> 00:28:23,090
to do is to maintain two
pointers into this state--

549
00:28:23,090 --> 00:28:29,800
A and B. And when we-- I'm
identifying with black here.

550
00:28:29,800 --> 00:28:32,680
When we specify X1
equals A, we would

551
00:28:32,680 --> 00:28:36,970
like to know what character's
being pointed to by pointer A.

552
00:28:36,970 --> 00:28:40,640
And then we'd like to advance
A to the next character.

553
00:28:40,640 --> 00:28:41,140
OK?

554
00:28:41,140 --> 00:28:44,180
When we request B,
with X1 equals B,

555
00:28:44,180 --> 00:28:46,395
we want to know what
character is at position B,

556
00:28:46,395 --> 00:28:48,020
and then advance to
the next character.

557
00:28:48,020 --> 00:28:51,940
So there's one strain that
we're trying to look at.

558
00:28:51,940 --> 00:28:55,200
And each white player has to
maintain an A pointer and a B

559
00:28:55,200 --> 00:28:56,470
pointer.

560
00:28:56,470 --> 00:28:59,490
And as black, we can
make independent requests

561
00:28:59,490 --> 00:29:00,530
to each of the two.

562
00:29:00,530 --> 00:29:07,720
It's like you have two disks
with two heads on the disk.

563
00:29:07,720 --> 00:29:09,810
And they both have
the exact same data.

564
00:29:09,810 --> 00:29:11,400
Or they're supposed to.

565
00:29:11,400 --> 00:29:13,320
And I can say, give
me the next character

566
00:29:13,320 --> 00:29:14,700
at this pointer from this disk.

567
00:29:14,700 --> 00:29:17,670
And I can give you-- ask for
what is-- simultaneously,

568
00:29:17,670 --> 00:29:20,030
I get one character
from one of the two

569
00:29:20,030 --> 00:29:21,410
pointers on the other disk.

570
00:29:21,410 --> 00:29:23,506
And then it advances by one.

571
00:29:23,506 --> 00:29:24,070
OK?

572
00:29:24,070 --> 00:29:25,829
Seems almost the same.

573
00:29:25,829 --> 00:29:27,620
But that's what will
make this undecidable.

574
00:29:39,610 --> 00:29:40,110
OK.

575
00:29:44,970 --> 00:29:49,940
So here's the trick, how we're
going to build this algorithm.

576
00:29:49,940 --> 00:29:52,890
I mean, the real trick is
that we have nondeterminism.

577
00:29:52,890 --> 00:29:56,940
We're asking whether white wins.

578
00:29:56,940 --> 00:29:59,770
That means-- or whether
white has a winning strategy.

579
00:29:59,770 --> 00:30:01,660
For white to have
a winning strategy,

580
00:30:01,660 --> 00:30:06,610
that must mean it can win or the
white team can win, no matter

581
00:30:06,610 --> 00:30:09,130
how black plays.

582
00:30:09,130 --> 00:30:11,780
And black is just non--
so basically, black

583
00:30:11,780 --> 00:30:14,640
is nondeterministically
choosing between the A

584
00:30:14,640 --> 00:30:19,410
and the B pointer requests.

585
00:30:19,410 --> 00:30:21,090
And so what this is
saying is, no matter

586
00:30:21,090 --> 00:30:26,890
what sequence of As and Bs
you get, white must win.

587
00:30:26,890 --> 00:30:28,900
And winning is going
to happen because we

588
00:30:28,900 --> 00:30:33,870
will build this algorithm to
only output yes when it gets

589
00:30:33,870 --> 00:30:35,120
to a halt state, basically.

590
00:30:39,700 --> 00:30:43,050
The algorithm must not
complain, no matter how

591
00:30:43,050 --> 00:30:45,194
we choose the A and B sequence.

592
00:30:45,194 --> 00:30:46,860
So let me get to what
we're going to do.

593
00:30:53,850 --> 00:31:10,725
So the algorithm maintains--
let's call this white 1.

594
00:31:20,100 --> 00:31:23,820
I would like to
know when-- let me

595
00:31:23,820 --> 00:31:28,812
be specific-- when white 1's A
state equals white 2's B state.

596
00:31:28,812 --> 00:31:30,520
But in fact, we'll do
this for all pairs.

597
00:31:30,520 --> 00:31:31,530
It'll be four different things.

598
00:31:31,530 --> 00:31:32,140
A, B here.

599
00:31:32,140 --> 00:31:33,980
A, B here.

600
00:31:33,980 --> 00:31:35,860
But let's say I want to
know when white 1's A

601
00:31:35,860 --> 00:31:41,000
state is in exactly the same
place as white 2's B state.

602
00:31:41,000 --> 00:31:45,885
So we have-- in
some sense, there

603
00:31:45,885 --> 00:31:51,006
are two of the strains, one
for white 1, one for white 2.

604
00:31:51,006 --> 00:31:58,010
And I want to know when I have
just to read through a state

605
00:31:58,010 --> 00:32:01,700
by white 1 and I've also read
through the exact same state

606
00:32:01,700 --> 00:32:03,740
from white 2.

607
00:32:03,740 --> 00:32:08,250
So that will happen when--
first of all, both white players

608
00:32:08,250 --> 00:32:11,040
should have just
returned a hash mark.

609
00:32:11,040 --> 00:32:14,080
And then-- hash
tag, if you prefer.

610
00:32:14,080 --> 00:32:19,490
And then also, while we were
running through this tape,

611
00:32:19,490 --> 00:32:22,850
I see whether they happen to
always return the same result.

612
00:32:22,850 --> 00:32:41,290
So this will basically
happen when-- so whenever

613
00:32:41,290 --> 00:32:46,540
both A and-- so if we just ask
for A, A, and white 1 returns

614
00:32:46,540 --> 00:32:48,660
a hash mark and white
2 returns a hash mark,

615
00:32:48,660 --> 00:32:50,410
then we're going to
start paying attention

616
00:32:50,410 --> 00:32:52,380
to every single
character we see.

617
00:32:52,380 --> 00:32:55,800
If-- assuming we keep
playing A, A, is black.

618
00:32:55,800 --> 00:32:58,500
And this has to work for all
possible assigned choices of A,

619
00:32:58,500 --> 00:33:01,620
B. So in particular,
it will be an execution

620
00:33:01,620 --> 00:33:04,965
where we play A, A
throughout this entire state.

621
00:33:04,965 --> 00:33:07,590
And as we're doing that, we just
check, character by character,

622
00:33:07,590 --> 00:33:09,470
are they returning
exactly the same result,

623
00:33:09,470 --> 00:33:12,510
and have they, so
far-- have they always,

624
00:33:12,510 --> 00:33:13,870
since the last hash mark?

625
00:33:18,730 --> 00:33:19,230
OK?

626
00:33:19,230 --> 00:33:21,360
And if they did, that's a
constant space algorithm.

627
00:33:21,360 --> 00:33:22,943
I just compare
character by character.

628
00:33:22,943 --> 00:33:26,480
Remember the AND of all
of those comparisons.

629
00:33:26,480 --> 00:33:29,220
If they were all the same,
and I reach a hash mark,

630
00:33:29,220 --> 00:33:35,510
that means I know that both
the W1 strain and the W2

631
00:33:35,510 --> 00:33:38,637
strain just output
the same state.

632
00:33:38,637 --> 00:33:40,220
So that means the A
and the A pointers

633
00:33:40,220 --> 00:33:43,575
are in the same
place at this moment.

634
00:33:46,980 --> 00:33:47,540
Cool.

635
00:33:47,540 --> 00:33:49,080
That's not quite
where I want them.

636
00:33:49,080 --> 00:33:51,120
But at least I can detect that.

637
00:33:51,120 --> 00:33:51,620
OK?

638
00:33:51,620 --> 00:33:53,260
I can detect identical states.

639
00:33:53,260 --> 00:33:55,380
Remember, I can't even
store-- I can't even

640
00:33:55,380 --> 00:33:56,840
count A and B
because these could

641
00:33:56,840 --> 00:33:58,460
get to really huge numbers.

642
00:33:58,460 --> 00:34:01,780
That only buys me an exponential
when I write things in binary.

643
00:34:01,780 --> 00:34:04,660
So I can't afford to write
down the A and the B pointers.

644
00:34:04,660 --> 00:34:05,770
It's what I'd like to do.

645
00:34:05,770 --> 00:34:09,580
But I can check, oh, did they
just output the same state?

646
00:34:09,580 --> 00:34:10,860
So far so good?

647
00:34:10,860 --> 00:34:14,520
Now, what I'd really like them
to be is one step out of sync

648
00:34:14,520 --> 00:34:18,149
because what I do have a
streaming algorithm for is

649
00:34:18,149 --> 00:34:20,190
if I have the previous
data of the Turing machine

650
00:34:20,190 --> 00:34:22,469
and the proposed next date
of this Turing machine,

651
00:34:22,469 --> 00:34:26,090
and I compare them letter
by letter, I can just check,

652
00:34:26,090 --> 00:34:28,659
are all of the tape squares
identical except for the one

653
00:34:28,659 --> 00:34:30,370
that the pointer's on?

654
00:34:30,370 --> 00:34:33,050
And that got changed
by a simple rule.

655
00:34:33,050 --> 00:34:35,370
And then all the others
should be identical.

656
00:34:35,370 --> 00:34:37,090
So it's very easy,
in a streaming sense.

657
00:34:37,090 --> 00:34:39,739
If I'm giving the previous
state and the next state,

658
00:34:39,739 --> 00:34:41,260
I'd be happy.

659
00:34:41,260 --> 00:34:46,580
So my goal is to get W1 state
to be one step out of sync,

660
00:34:46,580 --> 00:34:48,046
one step behind W2 state.

661
00:34:51,061 --> 00:34:51,560
OK.

662
00:34:51,560 --> 00:34:55,960
So how can I make that happen?

663
00:35:15,150 --> 00:35:18,750
Again, so I mean, black
isn't really making-- well,

664
00:35:18,750 --> 00:35:21,370
black is making all possible
choices among A and B,

665
00:35:21,370 --> 00:35:22,990
at all times.

666
00:35:22,990 --> 00:35:25,890
So in particular, we can
consider the situation

667
00:35:25,890 --> 00:35:32,370
in which black plays, let's
say A for the W1 player,

668
00:35:32,370 --> 00:35:34,100
and plays B on the other player.

669
00:35:34,100 --> 00:35:38,780
W2's A state does not change
because we're advancing B.

670
00:35:38,780 --> 00:35:42,767
And then W1's
state is advancing.

671
00:35:42,767 --> 00:35:44,850
And if I keep doing that,
and then, at some point,

672
00:35:44,850 --> 00:35:46,516
I get a hash mark,
which I can obviously

673
00:35:46,516 --> 00:35:50,830
detect in constant space,
then I advance my finite state

674
00:35:50,830 --> 00:35:53,320
machine, and say,
OK, cool, that means

675
00:35:53,320 --> 00:35:57,530
W1 is one step ahead--
one state ahead of W2.

676
00:36:00,350 --> 00:36:03,790
And now I'm going to compare.

677
00:36:03,790 --> 00:36:11,010
So when that happens, so
then out of sync by 1.

678
00:36:17,420 --> 00:36:21,660
And now what I'd like to
happen next is X1 and X2 moves.

679
00:36:26,780 --> 00:36:29,760
Then now I'm going to run
my streaming algorithm

680
00:36:29,760 --> 00:36:32,960
to check that this was
a valid transition.

681
00:36:52,210 --> 00:36:55,470
So from whatever
W2 is outputting

682
00:36:55,470 --> 00:36:59,530
to whatever W1 is outputting
because W1 is ahead,

683
00:36:59,530 --> 00:37:00,930
that should be a valid state.

684
00:37:00,930 --> 00:37:05,450
So basically, I had--
I ran for some time.

685
00:37:05,450 --> 00:37:06,900
Who knows what happened.

686
00:37:06,900 --> 00:37:12,550
Then I got this thing which
is identical to this thing.

687
00:37:12,550 --> 00:37:13,340
I detect that.

688
00:37:13,340 --> 00:37:14,290
And I see a hash mark.

689
00:37:14,290 --> 00:37:17,570
So I say, OK, they must
be in the same state.

690
00:37:17,570 --> 00:37:20,490
Now I'm going to
skip over whatever

691
00:37:20,490 --> 00:37:22,650
state was written here.

692
00:37:22,650 --> 00:37:27,740
And then I'm going to check
that every thing I get here

693
00:37:27,740 --> 00:37:29,940
is a valid transition
for whenever I get here.

694
00:37:32,830 --> 00:37:34,240
So this should go to that.

695
00:37:34,240 --> 00:37:35,500
This should go to that.

696
00:37:35,500 --> 00:37:38,030
And I don't need any
memory to do this.

697
00:37:38,030 --> 00:37:40,030
I'm just looking at
this square, knowing

698
00:37:40,030 --> 00:37:43,750
the state of this machine,
looking at this square,

699
00:37:43,750 --> 00:37:46,020
making sure that was
a valid transition.

700
00:37:46,020 --> 00:37:48,522
Usually, it's just that
this is equal to that,

701
00:37:48,522 --> 00:37:50,480
except at the one place
where the tape head is,

702
00:37:50,480 --> 00:37:54,190
which is written in
that little symbol.

703
00:37:54,190 --> 00:37:56,347
And in that spot, I do
whatever the Turing machine

704
00:37:56,347 --> 00:37:57,180
does to that symbol.

705
00:37:57,180 --> 00:37:59,510
If the writes to
it, it might change.

706
00:37:59,510 --> 00:38:01,480
Maybe it moves the
pointer left or right.

707
00:38:01,480 --> 00:38:03,090
But in constant
space, I just need

708
00:38:03,090 --> 00:38:04,650
to know what's happening here.

709
00:38:04,650 --> 00:38:06,560
And maybe it's
neighboring squares.

710
00:38:06,560 --> 00:38:08,510
I can figure out what
should be written here.

711
00:38:08,510 --> 00:38:10,810
And if white 1 ever
does the wrong thing,

712
00:38:10,810 --> 00:38:14,100
if it's not a valid
transition, then I

713
00:38:14,100 --> 00:38:18,280
will say black wins
as this algorithm.

714
00:38:18,280 --> 00:38:24,160
So for white to win, it
can't make any mistakes.

715
00:38:24,160 --> 00:38:27,670
White has to conform to this
idea that basically, first,

716
00:38:27,670 --> 00:38:30,690
it-- well, it basically--
as it's playing,

717
00:38:30,690 --> 00:38:34,120
it must be computing whatever
the Turing machine that's

718
00:38:34,120 --> 00:38:36,650
part of the game, essentially.

719
00:38:36,650 --> 00:38:40,610
It's embedded in this
algorithm, the Turing machine.

720
00:38:40,610 --> 00:38:45,930
And so we have to-- it has to be
simulating the Turing machine,

721
00:38:45,930 --> 00:38:48,870
maintaining these pointers,
A and B, and running through.

722
00:38:48,870 --> 00:38:51,240
It has to do that
because it has to win,

723
00:38:51,240 --> 00:38:53,260
no matter what black does.

724
00:38:53,260 --> 00:38:56,530
And it could be that black
does this really weird sequence

725
00:38:56,530 --> 00:39:00,900
of As and Bs in order to
verify the one place where

726
00:39:00,900 --> 00:39:04,107
you lied about one of these
being an invalid transition.

727
00:39:04,107 --> 00:39:06,440
It will eventually check for
some choices of the A and B

728
00:39:06,440 --> 00:39:07,500
moves.

729
00:39:07,500 --> 00:39:09,470
It will check that it
was a valid transition,

730
00:39:09,470 --> 00:39:12,220
from here to here.

731
00:39:12,220 --> 00:39:17,870
And therefore, all
transitions must be valid.

732
00:39:17,870 --> 00:39:20,490
So it's a pretty crazy
use of essentially

733
00:39:20,490 --> 00:39:23,080
the universal quantifier
that's given to black.

734
00:39:26,101 --> 00:39:28,290
White has to win, no matter
what black's moves are.

735
00:39:31,200 --> 00:39:38,690
So you might ask, where is
the Turing machine state.

736
00:39:38,690 --> 00:39:40,560
And it's essentially
in the heads

737
00:39:40,560 --> 00:39:43,500
of the white players, which
are not represented directly

738
00:39:43,500 --> 00:39:44,750
by the game.

739
00:39:44,750 --> 00:39:48,660
The game is just, you know, what
is the state of this algorithm?

740
00:39:48,660 --> 00:39:51,450
And it's, in some sense,
informed by the history

741
00:39:51,450 --> 00:39:54,000
of the plays, the sequence
of moves that have been made.

742
00:39:58,560 --> 00:40:01,490
That's, in some sense,
where you can also see

743
00:40:01,490 --> 00:40:04,670
this long sequence of moves.

744
00:40:04,670 --> 00:40:07,316
I mean, each of these
got output at some point.

745
00:40:07,316 --> 00:40:09,940
But initially, you could sort of
think of, all of the execution

746
00:40:09,940 --> 00:40:11,184
was in the players' heads.

747
00:40:11,184 --> 00:40:13,350
Then they're just maintaining
these A and B pointers

748
00:40:13,350 --> 00:40:14,340
and playing.

749
00:40:14,340 --> 00:40:17,450
And there must be such an
execution in order for white

750
00:40:17,450 --> 00:40:18,340
to win.

751
00:40:18,340 --> 00:40:22,270
So white will win, if, and only
if, there's a-- the machine

752
00:40:22,270 --> 00:40:26,860
halts, basically, because this
algorithm only output yes--

753
00:40:26,860 --> 00:40:30,110
output that white wins
when the machine halts.

754
00:40:30,110 --> 00:40:33,160
And it will report that black
wins, if you ever cheat.

755
00:40:33,160 --> 00:40:35,970
So you have to not cheat.

756
00:40:35,970 --> 00:40:39,640
And you have to get
to a halting state.

757
00:40:39,640 --> 00:40:40,470
It's pretty crazy.

758
00:40:40,470 --> 00:40:42,990
And this probably won't make
sense the first or second time.

759
00:40:42,990 --> 00:40:47,000
But it's clear to me,
again, every time I learn.

760
00:40:47,000 --> 00:40:49,235
It's like, oh, yeah,
that's really cool.

761
00:40:49,235 --> 00:40:50,860
Hopefully, it will
become clear to you.

762
00:40:50,860 --> 00:40:52,120
But if there are any questions--

763
00:40:52,120 --> 00:40:54,120
AUDIENCE: Why is it
important that the algorithm

764
00:40:54,120 --> 00:40:56,730
is only one space, in
the first place, though?

765
00:40:56,730 --> 00:41:00,490
PROFESSOR: I mean,
it's not technically--

766
00:41:00,490 --> 00:41:03,290
the overall algorithm is not
technically constant space

767
00:41:03,290 --> 00:41:06,450
because it needs to include the
entire Turing machine as part

768
00:41:06,450 --> 00:41:08,750
of it, to know how to run.

769
00:41:08,750 --> 00:41:11,900
But I mentioned that
the checking algorithm

770
00:41:11,900 --> 00:41:13,180
is constant space.

771
00:41:13,180 --> 00:41:18,980
And the point is, really, that
the size of this space key

772
00:41:18,980 --> 00:41:22,440
algorithm has to be only a
function of the given Turing

773
00:41:22,440 --> 00:41:23,890
machine.

774
00:41:23,890 --> 00:41:26,780
It can't depend on the
execution time or the execution

775
00:41:26,780 --> 00:41:28,300
space of the Turing machine.

776
00:41:28,300 --> 00:41:30,290
But that's all I
want to emphasize.

777
00:41:30,290 --> 00:41:33,726
So effectively, I mean, if you
think of the Turing machine

778
00:41:33,726 --> 00:41:35,350
as being pretty small,
but it's running

779
00:41:35,350 --> 00:41:39,900
for some huge amount of
time, like busy beaver time,

780
00:41:39,900 --> 00:41:41,800
relative to that, we're
thinking, basically,

781
00:41:41,800 --> 00:41:43,690
constant space.

782
00:41:43,690 --> 00:41:45,740
And in fact, we can get
away with constant space.

783
00:41:45,740 --> 00:41:47,440
That's for the checking part.

784
00:41:47,440 --> 00:41:49,360
That's my point.

785
00:41:49,360 --> 00:41:52,390
If you view the Turing machine
execution as an oracle.

786
00:41:52,390 --> 00:41:56,560
So when I check that this
goes to this-- in fact,

787
00:41:56,560 --> 00:42:00,210
I have to run the Turing
machine on this tape head input,

788
00:42:00,210 --> 00:42:02,300
to see what it would output.

789
00:42:02,300 --> 00:42:05,280
But the Turing machine
is inside the algorithm.

790
00:42:05,280 --> 00:42:08,260
So I can do that and
[INAUDIBLE] some time

791
00:42:08,260 --> 00:42:11,520
with the lookup table.

792
00:42:11,520 --> 00:42:14,330
So the point is, really, you
need, effectively, a streaming

793
00:42:14,330 --> 00:42:17,360
algorithm to do this
because these states get

794
00:42:17,360 --> 00:42:22,870
to be really, really
huge, because we

795
00:42:22,870 --> 00:42:26,780
want this reduction
to be polynomial time.

796
00:42:26,780 --> 00:42:29,964
And it is.

797
00:42:29,964 --> 00:42:31,630
Basically, copy the
Turing machine over,

798
00:42:31,630 --> 00:42:34,810
write some constant amount
of code to do this checking,

799
00:42:34,810 --> 00:42:37,690
and that's all you need.

800
00:42:37,690 --> 00:42:39,700
I guess we don't need it
to be polynomial time.

801
00:42:39,700 --> 00:42:40,440
But it is.

802
00:42:40,440 --> 00:42:42,070
So it's kind of nice.

803
00:42:42,070 --> 00:42:45,440
But we need that
it's finite time.

804
00:42:45,440 --> 00:42:48,090
And there's no finite way
to give an upper bound

805
00:42:48,090 --> 00:42:49,840
on the running time
of the Turing machine,

806
00:42:49,840 --> 00:42:50,980
other than running it.

807
00:42:50,980 --> 00:42:55,530
So polynomial time is good.

808
00:42:58,740 --> 00:43:00,810
OK.

809
00:43:00,810 --> 00:43:03,850
Let me briefly mention a
more formula-oriented game.

810
00:43:11,790 --> 00:43:13,265
This is not terribly exciting.

811
00:43:17,567 --> 00:43:18,900
I'll just write it down quickly.

812
00:43:38,570 --> 00:43:44,280
Basically, you can convert this
problem-- team computation game

813
00:43:44,280 --> 00:43:47,270
where black is forced to run
a particular machine-- you can

814
00:43:47,270 --> 00:43:49,580
convert machines into formulas.

815
00:43:49,580 --> 00:43:52,870
So it ends up looking
something like this.

816
00:43:52,870 --> 00:43:54,315
It might be possible
to simplify.

817
00:44:03,779 --> 00:44:05,445
This is one thing
that definitely works.

818
00:44:32,660 --> 00:44:33,160
OK.

819
00:44:33,160 --> 00:44:38,670
So again, white 1 can only
see one variable-- X1--

820
00:44:38,670 --> 00:44:40,060
that is set by black.

821
00:44:40,060 --> 00:44:42,480
And white 2 can only
see one variable-- X2--

822
00:44:42,480 --> 00:44:44,510
that's set by black.

823
00:44:44,510 --> 00:44:48,710
Black can set a bunch of
variables in one round.

824
00:44:48,710 --> 00:44:50,830
And there's some condition
that it has to satisfy.

825
00:44:50,830 --> 00:44:53,329
This will basically force you
to simulate the Turing machine

826
00:44:53,329 --> 00:44:55,560
and not break any rules.

827
00:44:55,560 --> 00:44:58,210
And if black ever
satisfies something,

828
00:44:58,210 --> 00:45:01,320
which is when the Turing
machine's, hey, black wins.

829
00:45:01,320 --> 00:45:02,370
Then black wins.

830
00:45:02,370 --> 00:45:04,720
And then you just turn
that into a formula.

831
00:45:04,720 --> 00:45:08,030
And then black sets
some other stuff.

832
00:45:08,030 --> 00:45:11,990
And so this is more in the
style of the dependency QBF.

833
00:45:11,990 --> 00:45:13,704
Again, you have this
kind of dependency.

834
00:45:13,704 --> 00:45:15,120
But now there are
multiple rounds.

835
00:45:15,120 --> 00:45:18,830
And now there's no bound to
the number of moves you make.

836
00:45:18,830 --> 00:45:21,440
We can reset
variables many times.

837
00:45:21,440 --> 00:45:24,990
And this is undecidable
by essentially simulating

838
00:45:24,990 --> 00:45:28,100
this machine, turning that
machine into a formula.

839
00:45:31,040 --> 00:45:35,551
So once we have that, we can
turn it into a constraint logic

840
00:45:35,551 --> 00:45:36,050
version.

841
00:45:36,050 --> 00:45:40,270
This is the team private but
not bounded constraint logic.

842
00:45:40,270 --> 00:45:42,300
Pretty much the same setup.

843
00:45:42,300 --> 00:45:44,770
Black has these
variables, X and X prime.

844
00:45:44,770 --> 00:45:47,360
Y1 has these variables, Y1.

845
00:45:47,360 --> 00:45:49,620
Y2 has these variables, Y2.

846
00:45:49,620 --> 00:45:50,890
They're fed into this formula.

847
00:45:50,890 --> 00:45:53,240
And there are various
things to-- that

848
00:45:53,240 --> 00:45:56,010
when those conditions
that I wrote down happen,

849
00:45:56,010 --> 00:45:58,690
you trigger the
appropriate target edge.

850
00:45:58,690 --> 00:46:01,670
And then black wins, up there,
or white wins, down there.

851
00:46:01,670 --> 00:46:04,790
So not too exciting to go
through the details of that.

852
00:46:04,790 --> 00:46:10,070
But the result is team private
information constraint logic is

853
00:46:10,070 --> 00:46:12,820
undecidable for three players.

854
00:46:12,820 --> 00:46:14,750
And you can use a crossover.

855
00:46:14,750 --> 00:46:17,315
And you can make this
planar graphs if you want.

856
00:46:20,170 --> 00:46:24,784
Any more questions
about Undecidability?

857
00:46:24,784 --> 00:46:26,284
AUDIENCE: Are you
ever going to give

858
00:46:26,284 --> 00:46:31,057
some examples of
undecidable-- like real games?

859
00:46:31,057 --> 00:46:31,640
PROFESSOR: No.

860
00:46:31,640 --> 00:46:34,290
There are no known
good examples of games.

861
00:46:34,290 --> 00:46:36,952
These are the games, I'm afraid.

862
00:46:36,952 --> 00:46:38,170
Yeah.

863
00:46:38,170 --> 00:46:40,040
Sorry.

864
00:46:40,040 --> 00:46:45,190
So I would like to switch gears
and go to the extreme opposite.

865
00:46:45,190 --> 00:46:48,030
Instead of Undecidability,
when there's no algorithm,

866
00:46:48,030 --> 00:46:50,660
let's go back to good
old-fashioned polynomial time

867
00:46:50,660 --> 00:46:52,300
algorithms.

868
00:46:52,300 --> 00:46:53,955
I think you remember what P is.

869
00:46:57,300 --> 00:47:01,560
But let me tell you a stronger
notion of P, which comes up

870
00:47:01,560 --> 00:47:03,300
in parallel algorithms.

871
00:47:03,300 --> 00:47:06,580
There are many different
models of parallel computing.

872
00:47:06,580 --> 00:47:10,680
So it's a little
bit-- you know, it's

873
00:47:10,680 --> 00:47:15,100
hard to write down one
good model of computation

874
00:47:15,100 --> 00:47:16,650
for parallel computing.

875
00:47:16,650 --> 00:47:18,830
But fortunately, if we're
proving lower bounds,

876
00:47:18,830 --> 00:47:20,830
it doesn't matter whether
our model is good.

877
00:47:20,830 --> 00:47:25,010
It really matters that our
model is super powerful.

878
00:47:25,010 --> 00:47:26,700
If we can prove
something is impossible

879
00:47:26,700 --> 00:47:29,950
in a super powerful model, that
means it's impossible in weaker

880
00:47:29,950 --> 00:47:30,790
models too.

881
00:47:30,790 --> 00:47:35,250
So I'm going to give you a
super powerful model called NC.

882
00:47:35,250 --> 00:47:37,780
So NC is Nick's class,
named after Nick Pippinger,

883
00:47:37,780 --> 00:47:40,360
who did a lot of
parallel algorithms.

884
00:47:40,360 --> 00:47:44,130
And there are a few
equivalent definitions.

885
00:47:44,130 --> 00:47:45,680
Let me give you two of them.

886
00:47:56,850 --> 00:47:59,030
I would like my
problem to be solvable.

887
00:47:59,030 --> 00:48:01,980
With P, we wanted things to
be solvable in poly time.

888
00:48:01,980 --> 00:48:04,200
So a natural
improvement is that I

889
00:48:04,200 --> 00:48:08,200
want to run in poly log time
for parallel algorithms,

890
00:48:08,200 --> 00:48:10,310
given a huge number
of processors,

891
00:48:10,310 --> 00:48:12,840
but not incredibly huge--
just polynomial number

892
00:48:12,840 --> 00:48:14,550
of processors.

893
00:48:14,550 --> 00:48:15,050
OK?

894
00:48:17,715 --> 00:48:19,840
If I was given an exponential
number of processors,

895
00:48:19,840 --> 00:48:22,960
I could solve SAT and all
sorts of crazy things.

896
00:48:22,960 --> 00:48:25,540
So shouldn't go too extreme.

897
00:48:25,540 --> 00:48:28,800
But let's say polynomial--
not problems but processors.

898
00:48:33,594 --> 00:48:35,760
Polynomial number of
processors is reasonable, maybe

899
00:48:35,760 --> 00:48:37,349
a little overkill, but OK.

900
00:48:37,349 --> 00:48:38,890
With polynomial
number of processors,

901
00:48:38,890 --> 00:48:40,660
I'd like to get poly log time.

902
00:48:40,660 --> 00:48:44,470
That's a pretty
natural, good situation.

903
00:48:44,470 --> 00:48:46,600
I let these processors
communicate however

904
00:48:46,600 --> 00:48:48,800
they want, super fast.

905
00:48:48,800 --> 00:48:52,415
You can think of
it as a circuit.

906
00:48:55,592 --> 00:48:57,050
If you're thinking
about the p-set,

907
00:48:57,050 --> 00:48:59,170
you'll be thinking about
small weft circuits.

908
00:48:59,170 --> 00:49:03,690
But here, it's just good
old-fashioned depth.

909
00:49:03,690 --> 00:49:05,220
We want poly log depth.

910
00:49:05,220 --> 00:49:09,930
That will be the running time
if every gate of the circuit

911
00:49:09,930 --> 00:49:12,090
can run in parallel.

912
00:49:12,090 --> 00:49:14,750
You still have to run in
sequence, along the depth

913
00:49:14,750 --> 00:49:15,250
lines.

914
00:49:15,250 --> 00:49:18,111
But if there are a polynomial
number of gates-- OK,

915
00:49:18,111 --> 00:49:20,780
that should be, of size.

916
00:49:20,780 --> 00:49:23,760
Polynomial number of
gates and poly log depth,

917
00:49:23,760 --> 00:49:27,714
then in particular, this
gives you an algorithm.

918
00:49:27,714 --> 00:49:29,880
Each processor just waits
for the inputs to be ready

919
00:49:29,880 --> 00:49:32,890
and then writes out the output
to the next gate that it--

920
00:49:32,890 --> 00:49:37,524
or to whatever gates it has that
it's connected to by a wire.

921
00:49:37,524 --> 00:49:38,940
And you get an
algorithm that runs

922
00:49:38,940 --> 00:49:41,023
in poly log time, polynomial
number of processors.

923
00:49:41,023 --> 00:49:43,190
So whichever you think
of is more intuitive.

924
00:49:45,950 --> 00:49:48,260
OK.

925
00:49:48,260 --> 00:49:50,660
So I have a small example here.

926
00:49:50,660 --> 00:49:54,360
Suppose you want to sort n
numbers in the comparison

927
00:49:54,360 --> 00:49:55,980
model.

928
00:49:55,980 --> 00:49:56,986
You can do that.

929
00:49:56,986 --> 00:49:58,610
And there are good
algorithms to do it.

930
00:49:58,610 --> 00:50:00,318
I will give you a not
so great algorithm.

931
00:50:00,318 --> 00:50:02,620
But at least it works in NC.

932
00:50:02,620 --> 00:50:04,730
Namely, with n
squared processors,

933
00:50:04,730 --> 00:50:08,910
I'm going to compare, in
parallel, all pairs of items.

934
00:50:08,910 --> 00:50:12,170
I'm going to compare ai
to aj for all i and j.

935
00:50:12,170 --> 00:50:15,120
Now I know which items
are less than which.

936
00:50:15,120 --> 00:50:17,200
And now, for each
item i, I basically

937
00:50:17,200 --> 00:50:21,715
just want to compute how many
items are smaller than it.

938
00:50:21,715 --> 00:50:24,340
If there are items smaller than
it-- let's say all of the items

939
00:50:24,340 --> 00:50:26,520
are distinct-- then
that item should

940
00:50:26,520 --> 00:50:29,620
go to the I-th
position in the array.

941
00:50:29,620 --> 00:50:33,700
So it's going to compute
this matrix, i versus j.

942
00:50:33,700 --> 00:50:38,670
Each one says ai is
smaller or greater than aj.

943
00:50:38,670 --> 00:50:41,590
And now, for a
given-- what do I say,

944
00:50:41,590 --> 00:50:45,210
a given row-- I want to compute
how many less than signs

945
00:50:45,210 --> 00:50:46,620
are in that row.

946
00:50:46,620 --> 00:50:49,550
This is basically computing a
sum where I view less than as 1

947
00:50:49,550 --> 00:50:51,320
and greater than as 0.

948
00:50:51,320 --> 00:50:54,890
And you can compute a sum
of n items in log n time,

949
00:50:54,890 --> 00:50:56,599
just by building a binary tree.

950
00:50:56,599 --> 00:50:58,390
I'm going to add these
two guys in parallel

951
00:50:58,390 --> 00:51:00,890
with these two guys, and so on.

952
00:51:00,890 --> 00:51:02,655
And then I compute my sum.

953
00:51:05,360 --> 00:51:08,000
And I can do each of
these rows in parallel.

954
00:51:08,000 --> 00:51:10,850
So in log n time, I can
compute all of these sums.

955
00:51:10,850 --> 00:51:14,420
Then I know where every item
needs to go and put it there.

956
00:51:14,420 --> 00:51:17,770
So this is a little overkill,
that I use a ton of processors.

957
00:51:17,770 --> 00:51:18,820
But still polynomial.

958
00:51:18,820 --> 00:51:22,140
So in n square processors,
I can easily, in log n time,

959
00:51:22,140 --> 00:51:22,980
sort n numbers.

960
00:51:22,980 --> 00:51:24,480
There are more
efficient algorithms.

961
00:51:24,480 --> 00:51:27,380
But the point is when
you have a par-- when

962
00:51:27,380 --> 00:51:30,540
there is a parallel algorithm,
in this powerful model,

963
00:51:30,540 --> 00:51:33,160
you can do it without
too much effort.

964
00:51:33,160 --> 00:51:34,950
But what we're
going to show, here,

965
00:51:34,950 --> 00:51:41,140
is something called
P-hardness, which,

966
00:51:41,140 --> 00:51:44,780
assuming not all problems
can be solved in this--

967
00:51:44,780 --> 00:51:46,970
not all polynomial time
algorithms can be solved

968
00:51:46,970 --> 00:51:50,770
in this model, these
problems can't.

969
00:51:50,770 --> 00:51:52,680
Just like NP hardness.

970
00:51:52,680 --> 00:51:54,520
Note, in particular,
NC is contained

971
00:51:54,520 --> 00:51:56,890
in P. If I had
such an algorithm,

972
00:51:56,890 --> 00:51:58,290
I could simulate this algorithm.

973
00:51:58,290 --> 00:52:00,497
Because I have parallelism
only polynomial,

974
00:52:00,497 --> 00:52:02,830
I could simulate the whole
algorithm in polynomial time,

975
00:52:02,830 --> 00:52:03,330
still.

976
00:52:03,330 --> 00:52:06,160
So this is stronger
than being in P.

977
00:52:06,160 --> 00:52:12,360
And P hardness means
that all problems in NC

978
00:52:12,360 --> 00:52:17,970
can be reduced in the
usual Karp-style reduction,

979
00:52:17,970 --> 00:52:19,220
in P reduction.

980
00:52:19,220 --> 00:52:24,160
But now the reduction must
be a parallel time reduction.

981
00:52:24,160 --> 00:52:33,300
So it must be an NC
algorithm to your problem.

982
00:52:38,050 --> 00:52:40,940
So P-hard means you're as
hard as all problems in P.

983
00:52:40,940 --> 00:52:43,020
And reductions must be
parallel algorithms.

984
00:52:43,020 --> 00:52:45,620
They must in NC.

985
00:52:45,620 --> 00:52:50,600
And so this implies
that you're not in NC,

986
00:52:50,600 --> 00:52:58,200
assuming NC does
not equal P, which

987
00:52:58,200 --> 00:53:01,810
is another standard complexity
theoretic assumption.

988
00:53:01,810 --> 00:53:04,900
Makes sense-- not all problems
should be parallelizable.

989
00:53:04,900 --> 00:53:07,740
So in particular,
P-hard problems

990
00:53:07,740 --> 00:53:09,090
would be such problems.

991
00:53:09,090 --> 00:53:13,580
And P-complete, of course,
means you're in P and P-hard.

992
00:53:13,580 --> 00:53:14,080
OK.

993
00:53:17,912 --> 00:53:19,912
AUDIENCE: Shouldn't it
be that all problems in P

994
00:53:19,912 --> 00:53:21,856
can be reduced by
an NC algorithm?

995
00:53:25,080 --> 00:53:26,622
PROFESSOR: Yes.

996
00:53:26,622 --> 00:53:27,490
Thank you.

997
00:53:30,640 --> 00:53:32,240
All problems in P. Yeah.

998
00:53:32,240 --> 00:53:32,880
Cool.

999
00:53:32,880 --> 00:53:35,670
So all problems, presumably
including the ones

1000
00:53:35,670 --> 00:53:39,236
that are hard to parallelize--
not just the NC ones-- can

1001
00:53:39,236 --> 00:53:40,360
be reduced to your problem.

1002
00:53:40,360 --> 00:53:45,380
And so that means your problem
is probably in P minus NC.

1003
00:53:45,380 --> 00:53:45,880
Good.

1004
00:54:02,500 --> 00:54:16,590
So let me give you some
base P-complete problems,

1005
00:54:16,590 --> 00:54:21,410
starting with a very natural
one-- general machine

1006
00:54:21,410 --> 00:54:23,865
simulation, sequential machine.

1007
00:54:31,800 --> 00:54:32,300
OK?

1008
00:54:32,300 --> 00:54:40,060
So given a sequential algorithm,
such as a Turing machine,

1009
00:54:40,060 --> 00:54:42,220
run it for t steps.

1010
00:54:42,220 --> 00:54:44,110
Now, this is a
little bit subtle.

1011
00:54:52,932 --> 00:54:53,890
Let me write this down.

1012
00:54:53,890 --> 00:54:55,223
And then I'm going to modify it.

1013
00:54:59,390 --> 00:55:03,955
Does the algorithm, say,
halt within t steps?

1014
00:55:08,010 --> 00:55:09,820
Or does it keep running
for longer than t?

1015
00:55:09,820 --> 00:55:11,653
So this is a version
of the halting problem.

1016
00:55:11,653 --> 00:55:15,170
I mean, we-- same thing with
a nondeterministic Turing

1017
00:55:15,170 --> 00:55:16,100
machine.

1018
00:55:16,100 --> 00:55:20,157
Running for polynomial time was
our prototype for NP problems.

1019
00:55:20,157 --> 00:55:21,740
We've done this kind
of problem a lot.

1020
00:55:21,740 --> 00:55:23,489
We did a similar thing with W1.

1021
00:55:23,489 --> 00:55:24,530
It was a run for k steps.

1022
00:55:24,530 --> 00:55:26,410
And k was a parameter.

1023
00:55:26,410 --> 00:55:31,740
I want this problem to be in
P. But if I phrase it this way,

1024
00:55:31,740 --> 00:55:35,560
it would be X time complete
because t could represent

1025
00:55:35,560 --> 00:55:37,580
an exponentially large value.

1026
00:55:37,580 --> 00:55:40,190
So what I want is for
this to be encoded

1027
00:55:40,190 --> 00:55:43,307
in unary, which usually,
we're not supposed to do.

1028
00:55:43,307 --> 00:55:45,140
But here, I'm going to
explicitly say, look,

1029
00:55:45,140 --> 00:55:49,910
t is bounded by a polynomial
in the size of the machine--

1030
00:55:49,910 --> 00:55:53,230
or equivalently, it's
written in unary.

1031
00:55:53,230 --> 00:55:55,970
And now I can do this
in polynomial time.

1032
00:55:55,970 --> 00:55:57,870
Because I have t
steps to do it, I'll

1033
00:55:57,870 --> 00:55:59,930
just run the machine t steps.

1034
00:55:59,930 --> 00:56:00,430
OK?

1035
00:56:00,430 --> 00:56:04,100
So this is in P. And if
you believe anything is not

1036
00:56:04,100 --> 00:56:06,420
parallelizable, then this
shouldn't be because this

1037
00:56:06,420 --> 00:56:07,760
lets you simulate all things.

1038
00:56:07,760 --> 00:56:11,636
So pretty easy to reduce
all problems in P.

1039
00:56:11,636 --> 00:56:14,010
If they're in P, that means
there's an algorithm to solve

1040
00:56:14,010 --> 00:56:15,320
them, sequential algorithm.

1041
00:56:15,320 --> 00:56:16,449
So you plug it in here.

1042
00:56:16,449 --> 00:56:18,240
It's going to run for
only polynomial time.

1043
00:56:18,240 --> 00:56:20,020
So you can set t
to that polynomial.

1044
00:56:20,020 --> 00:56:21,970
And boom.

1045
00:56:21,970 --> 00:56:26,430
You know, the algorithm
halting is it's answering, yes.

1046
00:56:26,430 --> 00:56:29,571
Or you could change this
to returning s or whatever.

1047
00:56:32,950 --> 00:56:33,450
OK?

1048
00:56:33,450 --> 00:56:35,660
So that's actually how
you prove this problem is

1049
00:56:35,660 --> 00:56:38,225
P-hard, or actually P-complete.

1050
00:56:38,225 --> 00:56:40,058
AUDIENCE: Is there any
problem with symmetry

1051
00:56:40,058 --> 00:56:41,522
between yea and
no answers, here?

1052
00:56:44,240 --> 00:56:46,780
PROFESSOR: Here, yes
and no are the same.

1053
00:56:46,780 --> 00:56:47,340
Yeah.

1054
00:56:47,340 --> 00:56:48,900
Unlike NP.

1055
00:56:48,900 --> 00:56:50,582
NP had an asymmetry
between yes and no.

1056
00:56:50,582 --> 00:56:52,290
So I could also change
this to return no.

1057
00:56:52,290 --> 00:56:54,295
That would also be as hard.

1058
00:56:54,295 --> 00:56:54,794
Yeah.

1059
00:57:05,900 --> 00:57:07,990
But of course, this is
not a very useful problem.

1060
00:57:07,990 --> 00:57:09,115
It's just a starting point.

1061
00:57:09,115 --> 00:57:13,470
And it's a very natural
P-complete problem.

1062
00:57:13,470 --> 00:57:16,890
More useful for reductions
are these circuit

1063
00:57:16,890 --> 00:57:21,645
value problems, CVP.

1064
00:57:28,100 --> 00:57:30,660
This is going to be
like circuit set.

1065
00:57:30,660 --> 00:57:33,460
So with circuit set, we were
given an acyclic Boolean

1066
00:57:33,460 --> 00:57:39,431
circuit which had one output.

1067
00:57:39,431 --> 00:57:41,430
Or maybe we're given a
particular output we care

1068
00:57:41,430 --> 00:57:42,684
about.

1069
00:57:42,684 --> 00:57:45,100
And we wanted to know whether
there was some input setting

1070
00:57:45,100 --> 00:57:46,460
that made the output true.

1071
00:57:46,460 --> 00:57:48,180
Here, we are given
the input setting.

1072
00:57:55,920 --> 00:58:00,020
So I mean, the circuit actually
has the inputs written down,

1073
00:58:00,020 --> 00:58:02,250
like 0, 1, 1.

1074
00:58:02,250 --> 00:58:05,090
And then let's say
we take an AND,

1075
00:58:05,090 --> 00:58:08,310
and then we take an OR,
something like that.

1076
00:58:08,310 --> 00:58:10,800
And we want to know, what
is this thing at the output?

1077
00:58:10,800 --> 00:58:12,841
Of course, this can be
solved in polynomial time.

1078
00:58:12,841 --> 00:58:15,030
You compute this
AND, and you get a 0.

1079
00:58:15,030 --> 00:58:16,285
This was a 1.

1080
00:58:16,285 --> 00:58:18,840
So you compute this
OR, and you get 1.

1081
00:58:18,840 --> 00:58:20,205
So the answer is 1.

1082
00:58:20,205 --> 00:58:20,705
OK?

1083
00:58:20,705 --> 00:58:23,940
And you can do that
in linear time.

1084
00:58:23,940 --> 00:58:25,730
But to do it parallel
is really hard

1085
00:58:25,730 --> 00:58:28,290
because it's really
hard to predict what

1086
00:58:28,290 --> 00:58:29,570
these inputs are going to be.

1087
00:58:29,570 --> 00:58:31,500
So you can't do
anything on this gate

1088
00:58:31,500 --> 00:58:34,100
until the inputs are ready.

1089
00:58:34,100 --> 00:58:38,040
So presumably, this circuit
will not have poly log depth.

1090
00:58:38,040 --> 00:58:40,480
Otherwise, it isn't in NC.

1091
00:58:40,480 --> 00:58:43,070
But if you have a really large
debt circuit, simulating--

1092
00:58:43,070 --> 00:58:47,180
running it in parallel is
just as hard as this problem.

1093
00:58:47,180 --> 00:58:50,190
So you can reduce a
general machine simulation

1094
00:58:50,190 --> 00:58:51,160
to a circuit value.

1095
00:58:51,160 --> 00:58:53,240
And the standard way
of converting machines

1096
00:58:53,240 --> 00:58:56,550
into circuits, that's the
electrical engineering problem.

1097
00:58:56,550 --> 00:58:57,050
OK.

1098
00:58:57,050 --> 00:58:58,040
What was the question?

1099
00:58:58,040 --> 00:58:59,270
Is the output true?

1100
00:59:06,490 --> 00:59:07,560
OK.

1101
00:59:07,560 --> 00:59:09,630
Now, there are
many special cases

1102
00:59:09,630 --> 00:59:11,120
of this that are also hard.

1103
00:59:11,120 --> 00:59:15,230
For example, NAM CVP.

1104
00:59:15,230 --> 00:59:15,730
OK.

1105
00:59:15,730 --> 00:59:17,580
We know how to build
computers out of NAND.

1106
00:59:17,580 --> 00:59:20,030
We know how to build
computers out of NOR.

1107
00:59:20,030 --> 00:59:20,530
Cool.

1108
00:59:20,530 --> 00:59:23,570
So that's easy.

1109
00:59:23,570 --> 00:59:26,750
More interesting
is monotone CVP.

1110
00:59:29,660 --> 00:59:33,510
So in monotone CVP, you
just have AND and OR gates.

1111
00:59:33,510 --> 00:59:37,500
You don't have negation or
an AND or an OR or an XOR.

1112
00:59:37,500 --> 00:59:38,770
Those sorts of things.

1113
00:59:38,770 --> 00:59:41,200
This is also hard, essentially.

1114
00:59:41,200 --> 00:59:43,920
By dual-rail logic, representing
the true and the false

1115
00:59:43,920 --> 00:59:46,720
as separate wires and
manipulating them,

1116
00:59:46,720 --> 00:59:48,600
you can get this to be hard.

1117
00:59:48,600 --> 00:59:50,670
Also kind of similar
to constraint logic.

1118
00:59:50,670 --> 00:59:52,316
OK?

1119
00:59:52,316 --> 00:59:55,320
But I won't prove it here.

1120
00:59:55,320 --> 00:59:59,310
A little stronger is
alternating monotone CVP.

1121
01:00:01,870 --> 01:00:10,680
This alternates AND
OR down any path.

1122
01:00:10,680 --> 01:00:14,970
So if you take a path from
an input bit to the output,

1123
01:00:14,970 --> 01:00:17,860
it alternates AND
OR, AND OR, AND OR.

1124
01:00:17,860 --> 01:00:20,940
And furthermore, we can
assume that it starts and ends

1125
01:00:20,940 --> 01:00:21,440
with OR.

1126
01:00:25,270 --> 01:00:26,950
It's nice to nail this down.

1127
01:00:26,950 --> 01:00:29,650
It's not hard to prove.

1128
01:00:29,650 --> 01:00:32,670
But I will prove it in a
moment, once I tell you

1129
01:00:32,670 --> 01:00:37,691
a general enough version
that I want to analyze.

1130
01:00:37,691 --> 01:00:39,690
This will just let us
worry about fewer gadgets.

1131
01:00:39,690 --> 01:00:42,650
So up here, we had to think
about all Boolean gates.

1132
01:00:42,650 --> 01:00:44,480
Now we just have to
think about AND and OR.

1133
01:00:44,480 --> 01:00:46,354
And we can always assume
the output of an AND

1134
01:00:46,354 --> 01:00:48,680
is the input of an
OR, and vice versa,

1135
01:00:48,680 --> 01:00:51,640
and that we only need to
connect inputs to OR gates

1136
01:00:51,640 --> 01:00:53,770
and not like this
picture, and we only

1137
01:00:53,770 --> 01:00:56,815
have to get the output
from an OR gate.

1138
01:00:56,815 --> 01:00:59,190
So it reduces the number of
cases we need to worry about.

1139
01:01:04,340 --> 01:01:04,840
Yeah?

1140
01:01:04,840 --> 01:01:07,709
AUDIENCE: So is this
with bounded fanin?

1141
01:01:07,709 --> 01:01:08,750
PROFESSOR: Good question.

1142
01:01:15,040 --> 01:01:18,810
Basically, bounded fanin
doesn't matter with this model.

1143
01:01:18,810 --> 01:01:27,490
So usually, when NC is defined,
it's bounded fanin and fanout.

1144
01:01:27,490 --> 01:01:28,930
And there's another
class, called

1145
01:01:28,930 --> 01:01:32,960
AC, which is when you have
unbounded fanouts and fanin,

1146
01:01:32,960 --> 01:01:34,160
let's say.

1147
01:01:34,160 --> 01:01:36,762
But that only hurts
us by a log factor.

1148
01:01:36,762 --> 01:01:38,720
So it matters if you're
worried about something

1149
01:01:38,720 --> 01:01:43,590
called AC0 and NC0, when this is
0 and you want constant height.

1150
01:01:43,590 --> 01:01:45,730
AUDIENCE: It matters for
alternation, as well.

1151
01:01:45,730 --> 01:01:47,063
PROFESSOR: Please wait, I guess.

1152
01:01:49,410 --> 01:01:51,610
It won't matter, is the answer.

1153
01:01:51,610 --> 01:01:56,422
AUDIENCE: Is this the only
setting of starting and ending

1154
01:01:56,422 --> 01:01:58,690
that works?

1155
01:01:58,690 --> 01:01:59,470
PROFESSOR: Sorry?

1156
01:01:59,470 --> 01:02:01,261
AUDIENCE: Starting and
ending with both AND

1157
01:02:01,261 --> 01:02:02,220
or starting with AND?

1158
01:02:02,220 --> 01:02:02,750
PROFESSOR: Oh, yeah.

1159
01:02:02,750 --> 01:02:04,575
I think you could
also make this an AND,

1160
01:02:04,575 --> 01:02:06,497
although I haven't checked that.

1161
01:02:06,497 --> 01:02:08,330
I don't think it's
critical that this is OR.

1162
01:02:08,330 --> 01:02:11,172
But you could probably do one
of them in OR, one of them

1163
01:02:11,172 --> 01:02:12,680
in AND-- all of
those combinations.

1164
01:02:12,680 --> 01:02:14,822
But this is the one
I've seen proved.

1165
01:02:14,822 --> 01:02:16,280
We'd need to check
the other cases.

1166
01:02:16,280 --> 01:02:17,363
But I think it's not hard.

1167
01:02:21,570 --> 01:02:24,290
This is called AM2CVP.

1168
01:02:27,420 --> 01:02:30,370
Great acronyms.

1169
01:02:30,370 --> 01:02:33,320
Every gate has
fanin2 and fanout2.

1170
01:02:33,320 --> 01:02:36,630
So in particular, bounded
but also nice and uniform.

1171
01:02:36,630 --> 01:02:38,820
Every single-- not less
than or equal to 2.

1172
01:02:38,820 --> 01:02:41,424
This is exactly 2.

1173
01:02:41,424 --> 01:02:42,080
OK?

1174
01:02:42,080 --> 01:02:43,650
We'll prove that.

1175
01:02:43,650 --> 01:02:50,980
And even stronger,
synchronous AM2CVP.

1176
01:02:54,870 --> 01:02:58,060
I prefer AVP, personally.

1177
01:02:58,060 --> 01:02:59,085
So this is SAM2CVP.

1178
01:03:03,970 --> 01:03:06,870
Synchronous means that all
of the inputs of the gate

1179
01:03:06,870 --> 01:03:09,270
are available at
exactly the same time.

1180
01:03:09,270 --> 01:03:14,360
If you imagine running all of
the gates of depth i at time i,

1181
01:03:14,360 --> 01:03:16,270
then you can do that.

1182
01:03:16,270 --> 01:03:18,595
At time i, all gates of
depth i will be ready.

1183
01:03:18,595 --> 01:03:19,970
They'll have all
of their inputs.

1184
01:03:19,970 --> 01:03:24,430
In other words, a gate of
depth i has one of its inputs

1185
01:03:24,430 --> 01:03:25,530
at depth i, minus 1.

1186
01:03:25,530 --> 01:03:27,840
But in the synchronous
circuit, both of the inputs

1187
01:03:27,840 --> 01:03:29,710
will have depth i, minus 1.

1188
01:03:29,710 --> 01:03:33,010
And so at time i, you'll
actually be ready to do it.

1189
01:03:33,010 --> 01:03:35,480
This is useful, in
particular, for things

1190
01:03:35,480 --> 01:03:40,390
like constraint logic and
other constructions, as well.

1191
01:03:40,390 --> 01:03:41,880
One more.

1192
01:03:41,880 --> 01:03:44,179
Planar CVP.

1193
01:03:44,179 --> 01:03:45,720
I don't know how
many of these things

1194
01:03:45,720 --> 01:03:47,270
you can import into
the planar case.

1195
01:03:47,270 --> 01:03:51,070
Probably many of them.

1196
01:03:51,070 --> 01:03:54,960
But just like planar circuit
set, out of NAND and NOR,

1197
01:03:54,960 --> 01:03:56,680
for example, you can
build crossovers.

1198
01:03:56,680 --> 01:04:00,870
And so planar circuits
are also hard.

1199
01:04:00,870 --> 01:04:05,200
But actually, not all
of them because planar

1200
01:04:05,200 --> 01:04:13,420
monotone CVP is in NC.

1201
01:04:13,420 --> 01:04:16,650
So you can't take the
monotone AND OR- ness

1202
01:04:16,650 --> 01:04:20,650
with planarity, which is kind
of annoying because that problem

1203
01:04:20,650 --> 01:04:22,880
can be done in parallel.

1204
01:04:22,880 --> 01:04:25,030
But planar with an AND--
then you've got negation.

1205
01:04:25,030 --> 01:04:28,390
And you can build a crossover.

1206
01:04:28,390 --> 01:04:28,890
OK.

1207
01:04:28,890 --> 01:04:30,306
Let me prove some
of these things.

1208
01:04:30,306 --> 01:04:32,500
This was to give you a
flavor for what's hard.

1209
01:04:32,500 --> 01:04:36,820
Still, all of these
problems up are P-complete.

1210
01:04:42,640 --> 01:04:45,420
And we're going to do it
in a series of reductions.

1211
01:04:45,420 --> 01:04:54,245
So first, let's deal with
starting and ending with OR.

1212
01:04:54,245 --> 01:04:55,620
So this is the
part you'd switch.

1213
01:04:55,620 --> 01:04:57,300
If you want to start
or end with an AND,

1214
01:04:57,300 --> 01:04:59,210
it should be no problem.

1215
01:04:59,210 --> 01:05:00,600
So this is an input bit.

1216
01:05:00,600 --> 01:05:03,300
Either 0 or 1, they're going
to be drawn with squares.

1217
01:05:03,300 --> 01:05:04,680
Oh, I should
mention, by the way,

1218
01:05:04,680 --> 01:05:07,824
there's a textbook
devoted to P completeness.

1219
01:05:07,824 --> 01:05:08,740
It's a short textbook.

1220
01:05:08,740 --> 01:05:09,850
But it's a nice read.

1221
01:05:09,850 --> 01:05:10,730
And it's online.

1222
01:05:10,730 --> 01:05:13,440
So I linked to it
from the website now.

1223
01:05:13,440 --> 01:05:16,160
So if you want to learn a little
more, check out that book.

1224
01:05:16,160 --> 01:05:18,420
These are figures
from that book.

1225
01:05:18,420 --> 01:05:24,560
So if I have some input
being sent to some gates,

1226
01:05:24,560 --> 01:05:26,570
I'm just going to
put an OR there.

1227
01:05:26,570 --> 01:05:28,860
And let's say i OR
that bit with itself.

1228
01:05:28,860 --> 01:05:31,100
So now everything
starts with an OR.

1229
01:05:31,100 --> 01:05:32,386
Done.

1230
01:05:32,386 --> 01:05:34,010
If I want to make
things end with an OR

1231
01:05:34,010 --> 01:05:36,940
and they end with an AND,
I'll just put an OR gate.

1232
01:05:36,940 --> 01:05:39,090
I don't know why here
we use only one input,

1233
01:05:39,090 --> 01:05:40,510
here we put two inputs.

1234
01:05:40,510 --> 01:05:43,380
But I could have just
put one input up there.

1235
01:05:43,380 --> 01:05:45,489
I'm allowing, for now,
one input OR gate.

1236
01:05:45,489 --> 01:05:46,780
So I'm going to fix that later.

1237
01:05:46,780 --> 01:05:47,280
Question?

1238
01:05:47,280 --> 01:05:49,770
AUDIENCE: [INAUDIBLE]

1239
01:05:49,770 --> 01:05:51,640
PROFESSOR: Coming soon.

1240
01:05:51,640 --> 01:05:54,722
So this is just to
start and end with ORs.

1241
01:05:54,722 --> 01:05:56,930
Next thing I'd like to do
is make things alternating.

1242
01:05:56,930 --> 01:06:00,780
So if I have two gates--
actually, before I do this,

1243
01:06:00,780 --> 01:06:01,780
I need to do this later.

1244
01:06:01,780 --> 01:06:03,240
It's important to get
the sequence right.

1245
01:06:03,240 --> 01:06:05,420
First, I want to make sure
the fanout is less than

1246
01:06:05,420 --> 01:06:07,310
or equal to 2, in this way.

1247
01:06:07,310 --> 01:06:08,910
This is a standard trick.

1248
01:06:08,910 --> 01:06:12,160
If I have large fanout, I
just build a binary tree.

1249
01:06:12,160 --> 01:06:13,940
And you can put
ORs or ANDs here.

1250
01:06:13,940 --> 01:06:14,920
There's only one input.

1251
01:06:14,920 --> 01:06:16,980
So it doesn't do anything to it.

1252
01:06:16,980 --> 01:06:19,480
But now I have
fanout, at most, 2.

1253
01:06:19,480 --> 01:06:22,700
Fanin is whatever.

1254
01:06:22,700 --> 01:06:24,800
Did we deal with large fanin?

1255
01:06:24,800 --> 01:06:25,300
Not yet.

1256
01:06:28,910 --> 01:06:30,160
So I'm going to do that first.

1257
01:06:30,160 --> 01:06:32,374
This will make lots of
ORs next to each other.

1258
01:06:32,374 --> 01:06:35,040
But then whenever I have two ORs
or two ANDs next to each other,

1259
01:06:35,040 --> 01:06:37,010
I just add the opposite
gate, in between.

1260
01:06:37,010 --> 01:06:37,510
OK.

1261
01:06:37,510 --> 01:06:40,570
So now it's alternating
fanout, at most, 2.

1262
01:06:40,570 --> 01:06:43,870
So we've gotten this
property in a weak sense,

1263
01:06:43,870 --> 01:06:45,110
with less than or equal to 2.

1264
01:06:45,110 --> 01:06:48,140
We're going to fix the 1s later.

1265
01:06:48,140 --> 01:06:49,610
We haven't dealt with this yet.

1266
01:06:52,570 --> 01:06:54,790
I assumed-- sorry-- that
I'm starting with monotones.

1267
01:06:54,790 --> 01:06:56,080
So I just have ANDs and ORs.

1268
01:06:56,080 --> 01:06:57,475
No indication.

1269
01:06:57,475 --> 01:07:00,552
I'm reducing from monotone
CVP to these other problems.

1270
01:07:00,552 --> 01:07:02,260
I've got alternation,
starting and ending

1271
01:07:02,260 --> 01:07:05,260
with or and fanout, at
most, 2, at this point.

1272
01:07:05,260 --> 01:07:10,460
Next reduction is to
make fanin exactly 2.

1273
01:07:10,460 --> 01:07:12,060
So yeah.

1274
01:07:12,060 --> 01:07:14,220
I guess I didn't write it.

1275
01:07:14,220 --> 01:07:16,950
But we can use the same
trick on the other side.

1276
01:07:16,950 --> 01:07:19,210
If you have fanin
larger than 2, then you

1277
01:07:19,210 --> 01:07:22,060
can just take ANDs
and ANDs and ANDs.

1278
01:07:22,060 --> 01:07:24,540
So you can also get
fanin, at most, 2.

1279
01:07:24,540 --> 01:07:27,140
Now if I have fanin 1, which
I've used all over the place,

1280
01:07:27,140 --> 01:07:29,930
now I'm going to get rid of
it in two different ways.

1281
01:07:29,930 --> 01:07:32,820
If I have an OR gate
with one input that

1282
01:07:32,820 --> 01:07:35,290
happens to be an
AND or original bit,

1283
01:07:35,290 --> 01:07:37,660
I'll just add in
another input of 0.

1284
01:07:37,660 --> 01:07:39,410
That won't affect things.

1285
01:07:39,410 --> 01:07:43,380
And if I have an AND bit, I
would like to put a 1 here.

1286
01:07:43,380 --> 01:07:46,380
But I'm not allowed to feed a
number-- an input-- directly

1287
01:07:46,380 --> 01:07:49,550
to an AND gate because I want
to preserve the property that I

1288
01:07:49,550 --> 01:07:50,680
start and end with ORs.

1289
01:07:50,680 --> 01:07:52,440
So this is one thing
that would be--

1290
01:07:52,440 --> 01:07:54,981
you'd have to tweak a little
bit if you want to start and end

1291
01:07:54,981 --> 01:07:55,750
with ANDs.

1292
01:07:55,750 --> 01:07:57,949
But you can do, I
think, a similar trick.

1293
01:07:57,949 --> 01:07:59,740
I want to build the 1
bit using an OR gate.

1294
01:07:59,740 --> 01:08:01,840
So I take two one
bits, OR them together.

1295
01:08:01,840 --> 01:08:03,400
Now I have a 1
bit fed into here.

1296
01:08:03,400 --> 01:08:05,242
And then that will
just pass through.

1297
01:08:05,242 --> 01:08:05,780
OK?

1298
01:08:05,780 --> 01:08:07,550
So now I have fanin, exactly 2.

1299
01:08:07,550 --> 01:08:08,555
No 1s.

1300
01:08:08,555 --> 01:08:10,680
You can imagine this is
useful when you're actually

1301
01:08:10,680 --> 01:08:12,536
building gadgets
because then you don't

1302
01:08:12,536 --> 01:08:13,660
have to do all of the work.

1303
01:08:13,660 --> 01:08:14,535
AUDIENCE: [INAUDIBLE]

1304
01:08:18,973 --> 01:08:20,889
PROFESSOR: I haven't
dealt with fanout 2, yet.

1305
01:08:20,889 --> 01:08:22,979
At this point, just fanin 2.

1306
01:08:22,979 --> 01:08:26,711
So variables-- some of them
still only have fanout 1.

1307
01:08:26,711 --> 01:08:27,960
But they will have at most, 2.

1308
01:08:27,960 --> 01:08:31,590
So now we're going to
do fanout, exactly 2.

1309
01:08:31,590 --> 01:08:35,410
So what I'm going to
do is take my circuit,

1310
01:08:35,410 --> 01:08:38,109
make two copies of it.

1311
01:08:38,109 --> 01:08:40,660
There's the primed copy
and the original copy.

1312
01:08:40,660 --> 01:08:41,630
OK?

1313
01:08:41,630 --> 01:08:46,100
So now I just need to hook
things how I want them.

1314
01:08:46,100 --> 01:08:49,250
The inputs, which
are not drawn here--

1315
01:08:49,250 --> 01:08:53,425
if I have an input out
degree 1, then I'll

1316
01:08:53,425 --> 01:08:54,620
merge them into one copy.

1317
01:08:54,620 --> 01:08:55,834
Then I'll have out degree 2.

1318
01:08:55,834 --> 01:08:57,250
If they already
have out degree 2,

1319
01:08:57,250 --> 01:08:58,501
just leave them as two copies.

1320
01:08:58,501 --> 01:08:59,000
OK?

1321
01:08:59,000 --> 01:09:03,060
So now all of the inputs have
out degree 2, or fanout 2.

1322
01:09:03,060 --> 01:09:06,092
If I have an AND gate
with out degree 2, again,

1323
01:09:06,092 --> 01:09:06,800
I don't touch it.

1324
01:09:06,800 --> 01:09:08,300
I'll leave them as two copies.

1325
01:09:08,300 --> 01:09:13,479
If I have an AND gate with
one-- a fanout of one-- then

1326
01:09:13,479 --> 01:09:15,109
here are the two copies of it.

1327
01:09:15,109 --> 01:09:19,121
I basically want to add an extra
output that gets thrown away.

1328
01:09:19,121 --> 01:09:20,620
So because I have
to end with an OR,

1329
01:09:20,620 --> 01:09:21,600
I'm going to put it OR here.

1330
01:09:21,600 --> 01:09:22,683
And then that's an output.

1331
01:09:22,683 --> 01:09:25,090
It's not the output that we're
asking the question about,

1332
01:09:25,090 --> 01:09:28,370
where I want to know, does
the output become true?

1333
01:09:28,370 --> 01:09:29,419
That's a specific output.

1334
01:09:29,419 --> 01:09:30,960
So for this reduction
I need to allow

1335
01:09:30,960 --> 01:09:33,560
there to be multiple
outputs in my circuit,

1336
01:09:33,560 --> 01:09:36,649
but only one of
them of interest.

1337
01:09:36,649 --> 01:09:37,910
OK?

1338
01:09:37,910 --> 01:09:39,930
And the rest is
connected as before.

1339
01:09:39,930 --> 01:09:43,350
So now these guys have fanout 2.

1340
01:09:43,350 --> 01:09:45,350
If I have an OR gate
with one output,

1341
01:09:45,350 --> 01:09:48,470
this is a little trickier
because I want to end with ORs,

1342
01:09:48,470 --> 01:09:49,597
I guess.

1343
01:09:49,597 --> 01:09:51,180
We're going to combine
these two bits.

1344
01:09:51,180 --> 01:09:52,179
And I have to alternate.

1345
01:09:52,179 --> 01:09:55,390
So next thing is I
have to go to an AND.

1346
01:09:55,390 --> 01:09:57,220
This also has to
have two outputs.

1347
01:09:57,220 --> 01:10:01,760
So I'm going to put one of
them here and one of them here.

1348
01:10:01,760 --> 01:10:03,261
These guys need two
inputs because I

1349
01:10:03,261 --> 01:10:05,593
don't want to [INAUDIBLE]
with the two input conditions.

1350
01:10:05,593 --> 01:10:06,862
So I add another bit.

1351
01:10:06,862 --> 01:10:07,570
It could be 0, 1.

1352
01:10:07,570 --> 01:10:08,350
It doesn't matter.

1353
01:10:08,350 --> 01:10:09,350
Feed it to both of them.

1354
01:10:09,350 --> 01:10:10,890
Now this has out degree 2.

1355
01:10:10,890 --> 01:10:12,660
These have in degree 2.

1356
01:10:12,660 --> 01:10:13,660
And this is an output.

1357
01:10:13,660 --> 01:10:18,034
So output is-- you could think
of there as being two of them.

1358
01:10:18,034 --> 01:10:18,958
Yeah?

1359
01:10:18,958 --> 01:10:20,833
AUDIENCE: Can you chain
the outputs together,

1360
01:10:20,833 --> 01:10:22,192
so that there's a 1 output?

1361
01:10:22,192 --> 01:10:24,650
PROFESSOR: Oh, combine the
different outputs together?

1362
01:10:24,650 --> 01:10:26,316
AUDIENCE: If you have
fanout, exactly 2,

1363
01:10:26,316 --> 01:10:28,761
and fanin, exactly
2, doesn't that

1364
01:10:28,761 --> 01:10:32,994
mean that you're preserving
the number of inputs,

1365
01:10:32,994 --> 01:10:38,090
So that you can't reduce
those extra outputs to 1?

1366
01:10:38,090 --> 01:10:38,980
PROFESSOR: Yes.

1367
01:10:38,980 --> 01:10:39,480
Good.

1368
01:10:39,480 --> 01:10:42,980
So I think if we tried to
combine all of the outputs

1369
01:10:42,980 --> 01:10:45,850
together, we'd end up
with a similar problem.

1370
01:10:45,850 --> 01:10:48,100
And we'd basically have to
do this construction again,

1371
01:10:48,100 --> 01:10:50,580
and then produce more outputs.

1372
01:10:50,580 --> 01:10:52,101
Good.

1373
01:10:52,101 --> 01:10:52,600
Yeah.

1374
01:10:52,600 --> 01:10:56,422
So we violate fanin 2,
obviously, at the inputs.

1375
01:10:56,422 --> 01:10:57,130
But you're right.

1376
01:10:57,130 --> 01:10:59,480
After the input level,
the number of lines

1377
01:10:59,480 --> 01:11:01,250
should be preserved.

1378
01:11:01,250 --> 01:11:02,050
OK.

1379
01:11:02,050 --> 01:11:02,640
So never mind.

1380
01:11:02,640 --> 01:11:03,870
We do need multiple outputs.

1381
01:11:03,870 --> 01:11:06,430
And exactly one
of them is marked

1382
01:11:06,430 --> 01:11:10,014
as the one we care about,
whether an output's true.

1383
01:11:10,014 --> 01:11:11,670
Is that the end?

1384
01:11:11,670 --> 01:11:12,550
Yes.

1385
01:11:12,550 --> 01:11:18,450
At this point, we've proved
AM2CVP is P-complete.

1386
01:11:18,450 --> 01:11:19,920
OK.

1387
01:11:19,920 --> 01:11:20,660
So one more.

1388
01:11:20,660 --> 01:11:23,190
Reduction is for the
synchronous case.

1389
01:11:25,870 --> 01:11:27,695
This is cool.

1390
01:11:30,630 --> 01:11:33,255
Let me, maybe, first
say what we're doing.

1391
01:11:36,880 --> 01:11:39,886
So for the
synchronous reduction,

1392
01:11:39,886 --> 01:11:42,260
we're going to make n over 2
copies of the circuit, where

1393
01:11:42,260 --> 01:11:43,345
n is the number of gates.

1394
01:11:50,160 --> 01:11:52,770
At a high level, that's
what we're doing.

1395
01:11:52,770 --> 01:11:54,570
And basically,
the i-th copy will

1396
01:11:54,570 --> 01:11:56,200
feed into the i plus 1st copy.

1397
01:11:56,200 --> 01:11:59,860
Well, not quite, because we
want to alternate ANDs and ORs.

1398
01:11:59,860 --> 01:12:06,470
So in the i-th copy-- the
i-th copy of the circuit

1399
01:12:06,470 --> 01:12:14,640
will be the depth
levels 2i and 2i plus 1,

1400
01:12:14,640 --> 01:12:18,110
in the final circuit
that I'm producing, where

1401
01:12:18,110 --> 01:12:21,545
these are ANDs and inputs.

1402
01:12:25,690 --> 01:12:28,781
And this level is
going to be ORs.

1403
01:12:28,781 --> 01:12:29,280
OK?

1404
01:12:29,280 --> 01:12:32,480
So basically, I want to take
an AND level and an OR level

1405
01:12:32,480 --> 01:12:34,810
from one copy, then an
AND level and an OR level

1406
01:12:34,810 --> 01:12:37,800
from the next copy, and so on.

1407
01:12:37,800 --> 01:12:40,419
The inputs are a
little more subtle.

1408
01:12:40,419 --> 01:12:41,960
But in particular,
I'm at least going

1409
01:12:41,960 --> 01:12:43,335
to make the copies
of the inputs.

1410
01:12:43,335 --> 01:12:46,280
And I'm going to
change them later.

1411
01:12:46,280 --> 01:12:51,250
And so the outputs of
the ORs from one copy

1412
01:12:51,250 --> 01:12:55,660
will go to the inputs of
the ANDs in the next copy,

1413
01:12:55,660 --> 01:12:58,200
and vice versa.

1414
01:12:58,200 --> 01:13:01,740
So the outputs from the ANDs
stay within the same copy.

1415
01:13:01,740 --> 01:13:04,660
And then the outputs from
here go to the next copy.

1416
01:13:04,660 --> 01:13:08,200
Basically, this will force
synchronization, in a sense.

1417
01:13:08,200 --> 01:13:11,260
Now, the one tricky
part is the inputs.

1418
01:13:11,260 --> 01:13:16,490
I want the i-th copy to be
triggered at time 2i, exactly.

1419
01:13:16,490 --> 01:13:19,220
And so for that, I can't
just have the inputs.

1420
01:13:19,220 --> 01:13:21,520
Maybe some of the gates
in there take an input

1421
01:13:21,520 --> 01:13:24,120
from-- sort of straight.

1422
01:13:24,120 --> 01:13:26,750
I need to delay that
input from coming

1423
01:13:26,750 --> 01:13:32,060
and still preserve fanin and
fanout 2 and alternation.

1424
01:13:32,060 --> 01:13:36,910
So to do that, I'm going
to use this gadget.

1425
01:13:36,910 --> 01:13:40,420
So I just have the
same bit written twice.

1426
01:13:40,420 --> 01:13:42,540
And then I OR them
with themselves

1427
01:13:42,540 --> 01:13:44,580
and then AND then with
themselves and OR them.

1428
01:13:44,580 --> 01:13:44,830
OK?

1429
01:13:44,830 --> 01:13:45,840
It seems innocent enough.

1430
01:13:45,840 --> 01:13:48,090
That latter obviously will
not change any of the bits.

1431
01:13:48,090 --> 01:13:52,420
So just duplicating those
bits at every time step.

1432
01:13:52,420 --> 01:13:54,570
It's all about timing here.

1433
01:13:54,570 --> 01:13:55,800
And now here's the fun thing.

1434
01:13:55,800 --> 01:14:00,386
If this gate needs
this bit, obviously, I

1435
01:14:00,386 --> 01:14:01,510
can just take it out, here.

1436
01:14:01,510 --> 01:14:05,470
That will still
preserve fanout 2, here.

1437
01:14:05,470 --> 01:14:09,220
And if I'm taking
one bit from here,

1438
01:14:09,220 --> 01:14:11,680
I'm going to have to
throw away another bit.

1439
01:14:11,680 --> 01:14:15,700
And magically-- this is very
cool-- if I throw away a bit

1440
01:14:15,700 --> 01:14:18,350
here, it doesn't matter
what that bit value is.

1441
01:14:18,350 --> 01:14:20,430
This will still be X2.

1442
01:14:24,100 --> 01:14:30,470
You can think of the two cases--
either x2 is 0, in which case

1443
01:14:30,470 --> 01:14:33,780
this is 0, and then it doesn't
matter what this bit is.

1444
01:14:33,780 --> 01:14:34,640
It will output 0.

1445
01:14:34,640 --> 01:14:35,380
OK?

1446
01:14:35,380 --> 01:14:37,460
Or this bit could be a 1.

1447
01:14:37,460 --> 01:14:39,412
Then I go here.

1448
01:14:39,412 --> 01:14:41,870
And I mean, it actually doesn't
matter that it's preserved.

1449
01:14:41,870 --> 01:14:42,700
But it is.

1450
01:14:42,700 --> 01:14:44,130
I think it's kind of cool.

1451
01:14:44,130 --> 01:14:48,190
If this was a 1, then this will
output whatever that bit is.

1452
01:14:48,190 --> 01:14:50,910
But because, again,
this will be a 1

1453
01:14:50,910 --> 01:14:54,080
because it gets it
from here, then the OR

1454
01:14:54,080 --> 01:14:55,780
will turn it back into a 1.

1455
01:14:55,780 --> 01:14:57,260
So either way, the
bit is restored.

1456
01:14:57,260 --> 01:14:58,580
So you could actually
reuse this gadget

1457
01:14:58,580 --> 01:14:59,663
a few times if you wanted.

1458
01:14:59,663 --> 01:15:04,010
But we can also be lazy and just
make many copies of this gadget

1459
01:15:04,010 --> 01:15:06,640
because we have polynomial size.

1460
01:15:06,640 --> 01:15:09,580
So basically, we can get a 1
bit and also destroy an output,

1461
01:15:09,580 --> 01:15:14,850
basically, with
this kind of gadget,

1462
01:15:14,850 --> 01:15:17,270
and get the inputs to
be triggered exactly

1463
01:15:17,270 --> 01:15:18,020
at the right time.

1464
01:15:18,020 --> 01:15:22,789
So the i-th copy-- all of the
gates will trigger at time 2i.

1465
01:15:22,789 --> 01:15:24,830
And then all of the AND
gates will trigger at 2i.

1466
01:15:24,830 --> 01:15:26,205
And then all of
the OR gates will

1467
01:15:26,205 --> 01:15:27,610
trigger at time 2i, plus 1.

1468
01:15:27,610 --> 01:15:31,640
And they'll feed
into the next copy.

1469
01:15:31,640 --> 01:15:32,960
All of those will trigger.

1470
01:15:32,960 --> 01:15:33,580
And so on.

1471
01:15:33,580 --> 01:15:35,560
So it's a little bit redundant.

1472
01:15:35,560 --> 01:15:37,500
But it works.

1473
01:15:41,890 --> 01:15:43,800
And then the output
is going to be

1474
01:15:43,800 --> 01:15:47,780
the output of the last
copy, n over second copy,

1475
01:15:47,780 --> 01:15:50,120
I guess you'd call it.

1476
01:15:50,120 --> 01:15:51,250
OK.

1477
01:15:51,250 --> 01:15:55,630
So you can, of
course, convert this

1478
01:15:55,630 --> 01:15:58,290
into bounded deterministic
constraint logic, where

1479
01:15:58,290 --> 01:16:00,391
each edge only flips once.

1480
01:16:00,391 --> 01:16:03,084
Once you have the synchronous
version of CVP, it's very easy.

1481
01:16:03,084 --> 01:16:04,750
I didn't draw a
synchronous picture here

1482
01:16:04,750 --> 01:16:06,583
because it's tedious
to draw these pictures.

1483
01:16:06,583 --> 01:16:10,870
But if you just set these--
whichever the 1 bits are--

1484
01:16:10,870 --> 01:16:12,580
as your initially
active edges-- those

1485
01:16:12,580 --> 01:16:15,090
are the ones that just
flipped, just reversed,

1486
01:16:15,090 --> 01:16:17,040
then things will just
propagate and everything

1487
01:16:17,040 --> 01:16:19,920
will be timed exactly right,
whenever you arrive at a gate.

1488
01:16:19,920 --> 01:16:21,560
Both of the inputs
have just activated.

1489
01:16:21,560 --> 01:16:22,880
And then the output
will activate.

1490
01:16:22,880 --> 01:16:23,720
So just like before.

1491
01:16:23,720 --> 01:16:25,980
But now each edge only
has to reverse once.

1492
01:16:25,980 --> 01:16:28,420
And you'll get the
results at the end.

1493
01:16:28,420 --> 01:16:30,250
So deciding whether
the last edge flips

1494
01:16:30,250 --> 01:16:34,540
is the same as whether the
output was a 1 in the circuit.

1495
01:16:34,540 --> 01:16:37,110
Open problem, I guess, would
be to use bounded deterministic

1496
01:16:37,110 --> 01:16:38,860
constrain logic to
prove interesting games

1497
01:16:38,860 --> 01:16:40,910
P-complete or interesting
problems P-complete.

1498
01:16:40,910 --> 01:16:43,100
That hasn't been done.

1499
01:16:43,100 --> 01:16:51,510
But I have, for fun, an example
of the P completeness-- P

1500
01:16:51,510 --> 01:16:53,680
hardness reduction.

1501
01:16:53,680 --> 01:16:56,640
So suppose you want to
find an independence set.

1502
01:16:56,640 --> 01:16:57,890
Independence set is hard.

1503
01:16:57,890 --> 01:17:00,030
Suppose I want to find a
maximal independence set,

1504
01:17:00,030 --> 01:17:02,770
an independence set where I
can't add anymore vertices.

1505
01:17:02,770 --> 01:17:04,170
So here's a way to do that.

1506
01:17:04,170 --> 01:17:06,010
I start with nothing.

1507
01:17:06,010 --> 01:17:08,090
I do a for loop.

1508
01:17:08,090 --> 01:17:09,590
Let's say the
vertices are numbered.

1509
01:17:09,590 --> 01:17:11,870
It's going to be important.

1510
01:17:11,870 --> 01:17:18,070
And if I can add
that vertex, add it.

1511
01:17:18,070 --> 01:17:21,010
If V is not adjacent
to S, add it.

1512
01:17:21,010 --> 01:17:21,510
OK.

1513
01:17:21,510 --> 01:17:23,280
I mean, this whole
world is weird

1514
01:17:23,280 --> 01:17:25,280
because it's all about
polynomial time problems.

1515
01:17:25,280 --> 01:17:27,080
Here's a polynomial
time algorithm.

1516
01:17:27,080 --> 01:17:31,600
It produces what I would call
the lexically first maximal

1517
01:17:31,600 --> 01:17:35,170
independence set because
it adds 1, if it can.

1518
01:17:35,170 --> 01:17:38,550
And then, subject to that, it
adds 2 if it can, and so on.

1519
01:17:38,550 --> 01:17:40,840
I will always add one, I guess.

1520
01:17:40,840 --> 01:17:43,070
So with this
labeling of vertices,

1521
01:17:43,070 --> 01:17:45,810
it finds the lexically
smallest one.

1522
01:17:45,810 --> 01:17:47,950
Suppose you want to find
the lexically smallest

1523
01:17:47,950 --> 01:17:49,360
maximal independence set.

1524
01:17:49,360 --> 01:17:53,050
finding a maximal independence
set can be done in parallel.

1525
01:17:53,050 --> 01:17:55,890
But finding the lexically
smallest one cannot.

1526
01:17:55,890 --> 01:17:57,080
This is P-complete.

1527
01:18:01,570 --> 01:18:03,390
And the reduction is super cute.

1528
01:18:06,390 --> 01:18:13,800
Reduction from NOR CVP.

1529
01:18:13,800 --> 01:18:16,250
Suppose I give
you a NOR circuit,

1530
01:18:16,250 --> 01:18:19,710
and I want to know whether
the output becomes true.

1531
01:18:19,710 --> 01:18:23,180
What I'm going to do is
build a special vertex,

1532
01:18:23,180 --> 01:18:31,180
called 0, which is connected
to all of the 0 inputs.

1533
01:18:31,180 --> 01:18:33,650
So the circuit has 0
inputs and 1 inputs.

1534
01:18:33,650 --> 01:18:36,061
I'm going to make the
inputs into nodes.

1535
01:18:36,061 --> 01:18:36,560
OK?

1536
01:18:36,560 --> 01:18:38,560
And so there are some 1 nodes.

1537
01:18:38,560 --> 01:18:40,390
Those are just
going to be nodes.

1538
01:18:40,390 --> 01:18:43,280
They connect to
whatever the gates are.

1539
01:18:43,280 --> 01:18:46,180
Then these things are combined
with various gates, and so on.

1540
01:18:46,180 --> 01:18:48,450
I'm just going to replace
a gate with a node.

1541
01:18:48,450 --> 01:18:50,940
I'm going to replace
an input with a node.

1542
01:18:50,940 --> 01:18:52,900
And I'm going to add
a special node, 0,

1543
01:18:52,900 --> 01:18:55,080
which is numbered
first, that connects

1544
01:18:55,080 --> 01:18:57,870
to all of the 0 inputs.

1545
01:18:57,870 --> 01:19:01,570
And then I'm also going
to order the vertices

1546
01:19:01,570 --> 01:19:03,230
in a topological sort.

1547
01:19:03,230 --> 01:19:05,200
So this will have
the earliest number.

1548
01:19:05,200 --> 01:19:06,440
Then these guys.

1549
01:19:06,440 --> 01:19:07,380
And so on.

1550
01:19:07,380 --> 01:19:09,090
So any topological sort.

1551
01:19:09,090 --> 01:19:12,090
Lemma topological sorting
can be done in parallel.

1552
01:19:12,090 --> 01:19:14,250
There's an NC algorithm
for topological sorting.

1553
01:19:14,250 --> 01:19:19,250
We need that here because this
reduction has to be in NC.

1554
01:19:19,250 --> 01:19:23,570
But once you do
that, I claim that V

1555
01:19:23,570 --> 01:19:29,000
will be in S if, and only
if, that gate outputs a 1.

1556
01:19:31,710 --> 01:19:33,866
Proof by induction.

1557
01:19:33,866 --> 01:19:35,240
So initially, this
is going to be

1558
01:19:35,240 --> 01:19:38,550
put in the independent set,
which means these guys won't,

1559
01:19:38,550 --> 01:19:41,520
but these guys will because
they're lexically first--

1560
01:19:41,520 --> 01:19:43,834
or they're first in
the topological order--

1561
01:19:43,834 --> 01:19:44,625
and then induction.

1562
01:19:46,992 --> 01:19:48,450
There's only one
type of gate here.

1563
01:19:48,450 --> 01:19:49,330
It's a NOR.

1564
01:19:49,330 --> 01:19:51,620
So basically, this
guy will be circled

1565
01:19:51,620 --> 01:19:56,000
if, and only if, neither
of the inputs are circles.

1566
01:19:56,000 --> 01:19:56,940
So that's a NOR.

1567
01:19:56,940 --> 01:19:58,410
And so then the
decision question

1568
01:19:58,410 --> 01:20:00,850
is there's some last thing
corresponding to the output.

1569
01:20:00,850 --> 01:20:03,940
It's going to be circled if, and
only if, the circuit outputs 1.

1570
01:20:03,940 --> 01:20:04,960
And that's it.

1571
01:20:04,960 --> 01:20:07,130
It's kind of a
beautiful reduction.

1572
01:20:07,130 --> 01:20:09,760
And I just, for fun, I have a
list of some more P-complete

1573
01:20:09,760 --> 01:20:11,700
problems without proofs.

1574
01:20:11,700 --> 01:20:13,620
Game of Life, obviously.

1575
01:20:13,620 --> 01:20:16,930
When you're given a time bound
that is written in unary,

1576
01:20:16,930 --> 01:20:20,080
and I want to know, is this
cell alive at time t, where

1577
01:20:20,080 --> 01:20:22,940
t is written in unary, by
the proof we did already,

1578
01:20:22,940 --> 01:20:25,210
that's P-complete.

1579
01:20:25,210 --> 01:20:27,510
And just, it's with
the unary version.

1580
01:20:27,510 --> 01:20:29,640
Also, one-dimensional
cellular automata.

1581
01:20:29,640 --> 01:20:31,240
Same kind of thing.

1582
01:20:31,240 --> 01:20:32,360
Generalize geography.

1583
01:20:32,360 --> 01:20:34,510
Remember that PSPACE
complete problem.

1584
01:20:34,510 --> 01:20:36,846
But if you have an
acyclic directed graph,

1585
01:20:36,846 --> 01:20:38,720
and you want to solve
geography on an acyclic

1586
01:20:38,720 --> 01:20:40,761
directed graph-- so it's
a two player game-- that

1587
01:20:40,761 --> 01:20:43,460
can be done in polynomial time.

1588
01:20:43,460 --> 01:20:46,080
But it's P-complete.

1589
01:20:46,080 --> 01:20:48,030
If I have a point
set in the plane,

1590
01:20:48,030 --> 01:20:50,635
and I compute the convex
hull, remove those points,

1591
01:20:50,635 --> 01:20:52,510
compute the convex hull,
remove those points,

1592
01:20:52,510 --> 01:20:54,020
it's called an onion peeling.

1593
01:20:54,020 --> 01:20:58,010
And given a point, I want to
know, is it on the k-th layer

1594
01:20:58,010 --> 01:20:59,879
for some value k,
that's P-complete.

1595
01:20:59,879 --> 01:21:01,670
Basically, you have to
sequentially compute

1596
01:21:01,670 --> 01:21:04,580
the convex hulls.

1597
01:21:04,580 --> 01:21:07,390
Another good canonical
one is multilist ranking.

1598
01:21:07,390 --> 01:21:11,230
Suppose I give you k, say,
sorted lists of numbers,

1599
01:21:11,230 --> 01:21:14,600
and I want to know,
given an item,

1600
01:21:14,600 --> 01:21:17,610
what is its rank in
the union of the lists?

1601
01:21:17,610 --> 01:21:20,320
So items can appear
in multiple lists.

1602
01:21:20,320 --> 01:21:23,210
And I want to know, is it the
kth item, in sorted order,

1603
01:21:23,210 --> 01:21:24,150
in the union?

1604
01:21:24,150 --> 01:21:26,170
So basically, I want
to sort the union.

1605
01:21:26,170 --> 01:21:29,070
That's P-complete.

1606
01:21:29,070 --> 01:21:33,430
If I want to compute A mod
B1, mod B2, mod B3, mod B4,

1607
01:21:33,430 --> 01:21:35,660
n times-- so the
repeated mod-- I

1608
01:21:35,660 --> 01:21:38,830
want to know whether that
equals 0, that's P-complete.

1609
01:21:38,830 --> 01:21:41,270
If I wanted to--
linear programming,

1610
01:21:41,270 --> 01:21:43,190
that's polynomial time.

1611
01:21:43,190 --> 01:21:45,950
This is P-complete, even when
the coefficients are 0 and 1.

1612
01:21:45,950 --> 01:21:48,220
So this is called
strongly P-complete.

1613
01:21:48,220 --> 01:21:53,560
You don't need large numbers,
whereas something like max flow

1614
01:21:53,560 --> 01:21:59,657
is weakly P-complete and can be,
in the analogy to full P test--

1615
01:21:59,657 --> 01:22:01,740
fully polynomial time
approximation scheme-- there

1616
01:22:01,740 --> 01:22:04,520
is a fully RNC
approximation scheme.

1617
01:22:04,520 --> 01:22:06,620
R means there's randomization.

1618
01:22:06,620 --> 01:22:09,036
I think it's open, whether
you can get rid of that.

1619
01:22:09,036 --> 01:22:11,410
There's some fun open problems,
like deciding whether two

1620
01:22:11,410 --> 01:22:12,860
numbers are relatively prime.

1621
01:22:12,860 --> 01:22:14,550
It's conjectured
to be P-complete.

1622
01:22:14,550 --> 01:22:15,720
But we don't know.

1623
01:22:15,720 --> 01:22:20,440
Computing A or the B mod C is
conjectured to be P-complete.

1624
01:22:20,440 --> 01:22:24,770
Maximum matching is conjectured
to be-- with large edge

1625
01:22:24,770 --> 01:22:26,860
weights, it's conjectured
to be P-complete.

1626
01:22:26,860 --> 01:22:30,570
But there is a
pseudo RNC algorithm.

1627
01:22:30,570 --> 01:22:33,980
So if the weights are small,
and you allow randomization,

1628
01:22:33,980 --> 01:22:36,710
then it's parallelizable.

1629
01:22:36,710 --> 01:22:38,760
Another open problem
is graph isomorphism

1630
01:22:38,760 --> 01:22:41,329
with bounded degree,
which is polynomial time.

1631
01:22:41,329 --> 01:22:42,120
I didn't know that.

1632
01:22:42,120 --> 01:22:43,619
But bounded degree
graph isomorphism

1633
01:22:43,619 --> 01:22:45,604
is easy in a serial setting.

1634
01:22:45,604 --> 01:22:47,770
But a conjecture is it's
hard in a parallel setting.

1635
01:22:47,770 --> 01:22:50,950
So lots of things out there.

1636
01:22:50,950 --> 01:22:53,290
I don't see too many
papers about P completeness

1637
01:22:53,290 --> 01:22:53,980
these days.

1638
01:22:53,980 --> 01:22:55,540
But it's a fun thing.

1639
01:22:55,540 --> 01:22:58,790
Once you decide your problem is
in P, next thing, next level,

1640
01:22:58,790 --> 01:23:01,480
you can find hardness
anywhere, it turns out.

1641
01:23:01,480 --> 01:23:04,234
Next thing is to prove P
completeness for your problem,

1642
01:23:04,234 --> 01:23:05,900
make sure there's no
parallel algorithm,

1643
01:23:05,900 --> 01:23:07,720
or find an NC algorithm.

1644
01:23:07,720 --> 01:23:09,780
If you do the upper bound
side, once you have NC,

1645
01:23:09,780 --> 01:23:12,300
you want to get the
smallest depth possible.

1646
01:23:12,300 --> 01:23:14,400
That's another story.

1647
01:23:14,400 --> 01:23:15,140
Cool.

1648
01:23:15,140 --> 01:23:17,200
That's it for today.